// FILE: ./src/utils.rs
use fuzzt::{algorithms::SequenceMatcher, get_top_n};
use std::collections::HashSet;
use std::env;

use std::path::Path;

use crate::cli::command::CrabCommand;
use crate::shell::Shell;

use regex::Regex;

/// This function prints a message to the console when the program is
/// compiled in debug mode and does nothing in release mode.
///
/// # Arguments
///
/// * `message` - A string slice that holds the message to be logged.
///
/// # Examples
///
/// ```
/// debug_log("This is a debug log message.");
/// ```
#[cfg(debug_assertions)]
pub fn debug_log(message: &str) {
    println!("{message}");
}

#[cfg(not(debug_assertions))]
pub fn debug_log(_: &str) {
    // This function does nothing when not in debug mode.
}

/// Replaces an argument in a script.
///
/// This function takes a script and two strings `from_` and `to`. It replaces the last occurrence of `from_` in the script with `to`.
/// If `from_` does not occur at the end of the script, it replaces all occurrences of `from_` in the script with `to`.
///
/// # Arguments
///
/// * `script` - A string slice that holds the script.
/// * `from_` - The string to be replaced.
/// * `to` - The string to replace with.
///
/// # Returns
///
/// This function returns a new string with the replaced argument.
pub fn replace_argument(script: &str, from_: &str, to: &str) -> String {
    let re = Regex::new(&format!(" {}$", regex::escape(from_))).unwrap();
    let replaced_in_the_end = re.replace(script, &format!(" {to}"));

    if replaced_in_the_end != script {
        replaced_in_the_end.into_owned()
    } else {
        script.replace(&format!(" {from_} "), &format!(" {to} "))
    }
}

/// Replaces a broken command with close matches from a list of candidate commands.
///
/// Given a `CrabCommand` and a `broken` command string, this function attempts to find close matches
/// within a provided list of `matched` candidate strings. It then replaces the `broken` command in the
/// script of the `CrabCommand` with each of the close matches, trimming any leading or trailing whitespace.
///
/// # Arguments
///
/// * `command` - A reference to a `CrabCommand` that holds the script where the replacement should occur.
/// * `broken` - The string representing the broken command to be replaced.
/// * `matched` - A vector of string slices representing the candidate commands for replacement.
///
/// # Returns
///
/// This function returns a vector of strings, each containing the script of the `CrabCommand` with the
/// `broken` command replaced by one of the close matches.
///
/// # Examples
///
/// ```
/// let command = CrabCommand { script: "echo broken_command" };
/// let broken = "broken_command";
/// let matched = vec!["fixed_command1", "fixed_command2"];
/// let fixed_scripts = replace_command(&command, broken, matched);
/// assert_eq!(fixed_scripts, vec!["echo fixed_command1", "echo fixed_command2"]);
/// ```
pub fn replace_command(command: &CrabCommand, broken: &str, matched: Vec<&str>) -> Vec<String> {
    let candidate_commands = get_close_matches(broken, &matched, None, Some(0.2));
    let mut new_commands = Vec::<String>::new();
    for cmd in candidate_commands {
        new_commands.push(replace_argument(&command.script, broken, cmd.trim()));
    }
    new_commands
}

/// Returns the closest match for a given word from a list of possibilities.
///
/// # Arguments
///
/// * `word` - A string slice that holds the word for which to find the closest match.
/// * `possibilities` - A slice of string slices that holds the list of words to check against.
/// * `cutoff` - An Option that holds the cutoff similarity ratio. The function returns the closest match that has a similarity ratio greater than or equal to the cutoff. If the cutoff is None, it defaults to 0.6.
/// * `fallback_to_first` - A boolean that indicates whether to return the first word from the list of possibilities if no match is found that meets the cutoff.
///
/// # Returns
///
/// * An Option that contains a string slice. If a match is found, it contains the closest match. If no match is found, it contains None, unless `fallback_to_first` is true, in which case it contains the first word from the list of possibilities.
pub fn get_closest<'a>(
    word: &'a str,
    possibilities: &'a [&'a str],
    cutoff: Option<f64>,
    fallback_to_first: Option<bool>,
) -> Option<&'a str> {
    let cutoff = cutoff.unwrap_or(0.6);
    let fallback_to_first = fallback_to_first.unwrap_or(true);
    let matches = get_top_n(
        word,
        possibilities,
        Some(cutoff),
        Some(1),
        None,
        Some(&SequenceMatcher),
    );
    if matches.is_empty() {
        if fallback_to_first {
            Some(possibilities[0])
        } else {
            None
        }
    } else {
        Some(matches[0])
    }
}

/// Gets a list of close matches for a word from a list of possibilities.
///
/// # Arguments
///
/// * `word` - The word to find matches for.
/// * `possibilities` - A slice of strings representing the possibilities.
///
/// # Returns
///
/// A vector of close matches for the given word.
pub fn get_close_matches<'a>(
    word: &'a str,
    possibilities: &'a [&'a str],
    n_matches: Option<usize>,
    cutoff: Option<f64>,
) -> Vec<&'a str> {
    // TODO: Read parameters from config file
    let n = n_matches.unwrap_or(3);
    let cutoff = cutoff.unwrap_or(0.6);
    get_top_n(
        word,
        possibilities,
        Some(cutoff),
        Some(n),
        None,
        Some(&SequenceMatcher),
    )
}

/// Gets the alias for the OC_ALIAS environment variable or defaults to "crab".
///
/// # Returns
///
/// The alias as a String.
pub fn get_alias() -> String {
    env::var("OC_ALIAS").unwrap_or("crab".to_owned())
}

/// Gets a vector of all executables in the PATH excluding certain entry points.
///
/// # Returns
///
/// A vector of executable names.
pub fn get_all_executable() -> Vec<String> {
    let tf_entry_points = ["ohcrab", "crab"];

    let mut bins = vec![];

    if let Ok(path_var) = env::var("PATH") {
        for path in env::split_paths(&path_var) {
            if let Ok(iterdir) = Path::new(&path).read_dir() {
                for executable in iterdir.flatten() {
                    if let Ok(file_type) = executable.file_type() {
                        if !file_type.is_dir() {
                            if let Some(file_name) = executable.path().file_name() {
                                if let Some(name) = file_name.to_str() {
                                    if !tf_entry_points.contains(&name) {
                                        bins.push(name.to_string());
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    // TODO: Add shell aliases
    bins
}

/// Filters out history entries occurring immediately after the alias ("crab").
///
/// # Arguments
///
/// * `history` - A reference to a vector of strings representing the history.
/// * `oc_alias` - A reference to a string representing the alias to be filtered out.
///
/// # Returns
///
/// * Vector of strings where entries immediately after the alias have been filtered out.
fn not_corrected(history: &Vec<String>, oc_alias: &String) -> Vec<String> {
    let mut previous: Option<&str> = None;
    let mut result = Vec::new();

    for line in history {
        if let Some(prev) = previous {
            if line != oc_alias {
                result.push(prev.to_string());
            }
        }
        previous = Some(line);
    }

    if let Some(last) = history.last() {
        result.push(last.clone());
    }
    result
}

/// Returns a vector of valid history commands excluding the current command.
///
/// The method compares the command with executables and shell builtins and
/// ignores commands performed just after the alias is called ("crab").
///
/// # Arguments
///
/// * `command` - A reference to the current CrabCommand.
/// * `system_shell` - A reference to the system shell.
///
/// # Returns
///
/// * A vector of valid history commands as strings.
pub fn get_valid_history_without_current(
    command: &CrabCommand,
    system_shell: &dyn Shell,
) -> Vec<String> {
    let mut corrected: Vec<String> = Vec::new();
    let mut valid_history: Vec<String> = Vec::new();

    let history = system_shell.get_history(None);
    let mut executables = history.clone();
    executables.extend(system_shell.get_builtin_commands());
    executables.extend(get_all_executable());
    let executables: HashSet<_> = executables.into_iter().collect();

    for line in not_corrected(&history, &get_alias()) {
        let first_word = line.split_whitespace().next().unwrap_or(line.as_str());
        if !line.starts_with(&get_alias())
            & (line != command.script)
            & executables.contains(first_word)
        {
            valid_history.push(line);
        }
    }

    valid_history
}

/// Returns a vector of matched commands from the given stderr string.
///
/// This function iterates over each line in `stderr`. If a line contains any of the separators,
/// it sets a flag `should_yield` to true. For each subsequent line, if `should_yield` is true and
/// the line is not empty, the function adds the line to the vector of matched commands.
///
/// # Arguments
///
/// * `stderr` - A string slice that holds the standard error output.
/// * `separator_option` - An Option that contains a vector of separator strings. If this option is None,
///   the function uses ["Did you mean"] as the default separator.
///
/// # Returns
///
/// This function returns a vector of matched commands. Each command is a string that follows a line
/// containing a separator and does not contain a separator itself.
///
/// # Example
///
/// ```
/// let stderr = "error: pathspec 'feature/test_commit' did not match any file(s) known to git\nDid you mean this?\n    origin/feature/test_commit";
/// let commands = get_all_matched_commands(stderr, None);
/// assert_eq!(commands, vec!["origin/feature/test_commit"]);
/// ```
pub fn get_all_matched_commands(stderr: &str, separator_option: Option<Vec<&str>>) -> Vec<String> {
    let separator = match separator_option {
        None => vec!["Did you mean"],
        Some(sep) => sep,
    };
    let mut should_yield = false;
    let mut matched_commands = Vec::new();

    for line in stderr.lines() {
        if separator.iter().any(|&sep| line.contains(sep)) {
            should_yield = true;
        } else if should_yield && !line.is_empty() {
            matched_commands.push(line.trim().to_string());
        }
    }

    matched_commands
}

#[cfg(test)]
mod tests {
    use mockall::mock;

    use crate::{cli::command::CrabCommand, shell::Shell, utils::get_alias};

    use super::get_all_matched_commands;
    use super::get_valid_history_without_current;
    use rstest::rstest;

    mock! {
        pub MyShell {}
        impl Shell for MyShell {
            fn app_alias(&self, alias_name: &str) -> String;
            fn get_shell(&self) -> String;
            fn get_history_file_name(&self) -> String;
            fn script_from_history(&self, command_script: &str) -> String;
            fn get_history<'a>(&self, file_path: Option<&'a str>) -> Vec<String> ;
            fn get_builtin_commands(&self) -> Vec<String>;
        }
    }

    #[test]
    fn test_get_valid_history_without_current() {
        let command =
            CrabCommand::new("ls -l".to_owned(), Some("multiple\nlines".to_owned()), None);
        let mut mock_shell = MockMyShell::new();
        mock_shell
            .expect_get_builtin_commands()
            .returning(|| vec!["command1".to_string(), "command2".to_string()]);
        mock_shell.expect_get_history().returning(|_| {
            vec![
                "ls -l".to_string(),
                "command1".to_string(),
                "cmp a.txt b.txt".to_string(),
            ]
        });
        let system_shell: Box<dyn Shell> = Box::new(mock_shell);

        assert_eq!(
            vec!["command1", "cmp a.txt b.txt"],
            get_valid_history_without_current(&command, &*system_shell)
        );

        let mut mock_shell = MockMyShell::new();
        mock_shell
            .expect_get_builtin_commands()
            .returning(|| vec!["command1".to_string(), "command2".to_string()]);
        mock_shell.expect_get_history().returning(|_| {
            vec![
                "ls -l".to_string(),
                "cmp a.txt b.txt".to_string(),
                get_alias(),
            ]
        });
        let system_shell: Box<dyn Shell> = Box::new(mock_shell);
        // Skip "cmp a.txt b.txt" because it comes before "crab" (alias)
        assert_eq!(
            Vec::<String>::new(),
            get_valid_history_without_current(&command, &*system_shell)
        );
    }

    #[rstest]
    #[case("git: 'cone' is not a git command. See 'git --help'.\n\nDid you mean one of these?\n\tclone", vec!["clone"])]
    #[case("git: 're' is not a git command. See 'git --help'.\n\nDid you mean one of these?\n\trebase\n\treset\n\tgrep\n\trm", vec!["rebase", "reset", "grep", "rm"])]
    #[case("tsuru: \"target\" is not a tsuru command. See \"tsuru help\".\n\nDid you mean one of these?\n\tservice-add\n\tservice-bind\n\tservice-doc\n\tservice-info\n\tservice-list\n\tservice-remove\n\tservice-status\n\tservice-unbind", vec![ "service-add", "service-bind", "service-doc", "service-info", "service-list", "service-remove", "service-status", "service-unbind"])]
    fn test_get_all_matched_commands(#[case] stderr: &str, #[case] result: Vec<&str>) {
        assert_eq!(get_all_matched_commands(stderr, None), result);
    }
}

// FILE: ./src/main.rs
// #![allow(unused_imports)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(clippy::type_complexity)]

pub mod cli;
pub mod rules;
pub mod shell;
mod ui;
mod utils;

use cli::{
    command::run_command,
    parser::{get_parser, prepare_arguments},
};
use rules::get_corrected_commands;
use shell::{get_bash_type, Shell};
use std::env;

use crate::{ui::interactive_menu, utils::debug_log};

const ARGUMENT_PLACEHOLDER: &str = "OHCRAB_ARGUMENT_PLACEHOLDER";
const ENV_VAR_NAME_HISTORY: &str = "OHCRAB_COMMAND_HISTORY";
const ENV_VAR_NAME_ALIAS: &str = "OHCRAB_ALIAS";
const ENV_VAR_NAME_SHELL: &str = "OHCRAB_SHELL";

/// Handles the command correction logic.
fn handle_command_correction(
    command_values: clap::parser::Values<String>,
    system_shell: &dyn Shell,
    select_first: bool,
) {
    let command_vec: Vec<String> = command_values.collect();
    debug_log(&format!("Retrieved command(s): {:?}", command_vec));

    let mut crab_command = run_command(command_vec, system_shell);
    debug_log(&format!("Crab command: {:?}", crab_command));

    let corrected_commands = get_corrected_commands(&mut crab_command, system_shell);
    debug_log(&format!(
        "Candidate command(s): {:?}",
        corrected_commands
            .iter()
            .map(|cmd| cmd.script.to_owned())
            .collect::<Vec<_>>()
    ));

    let selected_command = if select_first {
        corrected_commands.first()
    } else {
        interactive_menu(&corrected_commands)
    };

    if let Some(valid_command) = selected_command {
        // Print a new line after the menu if in interactive mode
        if !select_first {
            eprintln!();
        }
        debug_log(&format!("Command selected: {:?}", valid_command));
        valid_command.run(crab_command);
    }
}

fn main() {
    // Skip the first element of `env::args()` (the name of program)
    let args: Vec<String> = env::args().skip(1).collect();
    let args = prepare_arguments(args);
    let mut arg_matches = get_parser().get_matches_from(args);
    let system_shell = get_bash_type(&arg_matches.remove_one::<String>("shell").unwrap());
    let select_first = arg_matches.get_flag("select-first");

    if let Some(command) = arg_matches.remove_many::<String>("command") {
        handle_command_correction(command, &*system_shell, select_first);
    } else {
        let alias_name = arg_matches.get_one::<String>("alias").unwrap();
        println!("{}", system_shell.app_alias(alias_name));
    }
}

// FILE: ./src/rules/cp_omitting_directory.rs
use super::{
    get_new_command_without_sudo, match_rule_without_sudo, utils::match_rule_with_is_app, Rule,
};
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command.script_parts.first().is_some_and(|s| s == "cp")
            && (output.contains("omitting directory") || output.contains("is a directory"))
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(
        |command| match_rule_with_is_app(auxiliary_match_rule, command, vec!["cp"], None),
        command,
    )
}

pub fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    let re = Regex::new(r"^cp ").unwrap();
    vec![re.replace_all(&command.script, "cp -a ").into_owned()]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "cp_omitting_directory".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("cp dir", "cp: dor: is a directory", true)]
    #[case("cp dir", "cp: omitting directory 'dir'", true)]
    #[case("some dir", "cp: dor: is a directory", false)]
    #[case("some dir", "cp: omitting directory 'dir'", false)]
    #[case("cp dir", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("cp dir", "", vec!["cp -a dir"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/hostscli.rs
use super::{
    get_new_command_without_sudo, match_rule_without_sudo, utils::match_rule_with_is_app, Rule,
};
use crate::{cli::command::CrabCommand, shell::Shell, utils::replace_command};
use regex::Regex;

const NO_COMMAND: &str = "Error: No such command";
const NO_WEBSITE: &str = "hostscli.errors.WebsiteImportError";

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains(NO_COMMAND) || output.contains(NO_WEBSITE)
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(
        |command| match_rule_with_is_app(auxiliary_match_rule, command, vec!["hostscli"], None),
        command,
    )
}

pub fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    if let Some(output) = &command.output {
        if output.contains(NO_WEBSITE) {
            vec!["hostscli websites".to_owned()]
        } else {
            let misspelled_command = Regex::new(r#"Error: No such command "(.*)""#)
                .unwrap()
                .captures(output)
                .and_then(|caps| caps.get(1).map(|m| m.as_str().to_owned()));
            match misspelled_command {
                None => vec![],
                Some(misspelled_command) => replace_command(
                    command,
                    &misspelled_command,
                    vec!["block", "unblock", "websites", "block_all", "unblock_all"],
                ),
            }
        }
    } else {
        vec![]
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "hostscli".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const ERROR_NO_WEBSITE: &str = "\nhostscli.errors.WebsiteImportError:\n\nNo Domain list found for website: a_website_that_does_not_exist\n\nPlease raise a Issue here: https://github.com/dhilipsiva/hostscli/issues/new\nif you think we should add domains for this website.\n\ntype `hostscli websites` to see a list of websites that you can block/unblock\n";

    #[rstest]
    #[case("hostscli block a_website_that_does_not_exist", ERROR_NO_WEBSITE, true)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("hostscli block a_website_that_does_not_exist", ERROR_NO_WEBSITE, vec!["hostscli websites"])]
    #[case("hostscli websitess", r#"Error: No such command "websitess""#, vec!["hostscli websites"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_commit_reset.rs
use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
};

use super::{utils::git::get_new_command_with_git_support, Rule};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    command.script_parts.contains(&"commit".to_owned())
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec!["git reset HEAD~".to_owned()]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_commit_reset".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("git commit -m \"test\"", "test output", true)]
    #[case("git commit", "", true)]
    #[case("git branch foo", "", false)]
    #[case("git checkout feature/test_commit", "", false)]
    #[case("git push", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git commit -m \"test commit\"", vec!["git reset HEAD~"])]
    #[case("git commit", vec!["git reset HEAD~"])]
    fn test_get_new_command(#[case] command: &str, #[case] expected: Vec<&str>) {
        let mut command = CrabCommand::new(command.to_owned(), Some("".to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_add.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};
use regex::Regex;
use shlex::Quoter; // Import the Quoter
use std::path::Path;

fn get_missing_file(command: &CrabCommand, path_exists: Option<bool>) -> Option<String> {
    if let Some(stdout) = &command.output {
        let re = Regex::new(r"error: pathspec '([^']*)' did not match any file\(s\) known to git.")
            .unwrap();

        if let Some(captures) = re.captures(stdout) {
            let path = &captures[1];
            if path.is_empty() {
                None
            } else if let Some(path_exists) = path_exists {
                if path_exists {
                    Some(path.to_owned())
                } else {
                    None
                }
            } else if Path::new(&path).exists() {
                Some(path.to_owned())
            } else {
                None
            }
        } else {
            None
        }
    } else {
        None
    }
}

fn mockable_match_rule(command: &CrabCommand, path_exists: Option<bool>) -> bool {
    if let Some(stdout) = &command.output {
        stdout.contains("did not match any file(s) known to git.")
            && get_missing_file(command, path_exists).is_some()
    } else {
        false
    }
}

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    mockable_match_rule(command, None)
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn mockable_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
    path_exists: Option<bool>,
) -> Vec<String> {
    let missing_file = get_missing_file(command, path_exists).unwrap_or_default();
    // Use the shlex Quoter to handle spaces and special characters
    let quoter = Quoter::new();
    let quoted_missing_file = quoter.quote(&missing_file).unwrap_or_default();

    let str_git_add = format!("git add -- {}", quoted_missing_file);
    vec![system_shell
        .unwrap()
        .and(vec![&str_git_add, &command.script])]
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    mockable_get_new_command(command, system_shell, None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_add".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{mockable_get_new_command, mockable_match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("git submodule update unknown", "unknown", true, true)]
    #[case("git commit unknown", "unknown", true, true)]
    #[case("git submodule update known", "", true, false)]
    #[case("git commit known", "", true, false)]
    fn test_match_rule(
        #[case] script: &str,
        #[case] target: &str,
        #[case] path_exists: bool,
        #[case] expected: bool,
    ) {
        let stdout = if !target.is_empty() {
            format!(
                "error: pathspec '{}' did not match any file(s) known to git.",
                target
            )
        } else {
            "".to_string()
        };
        let command = CrabCommand::new(script.to_owned(), Some(stdout), None);
        assert_eq!(mockable_match_rule(&command, Some(path_exists)), expected);
    }

    #[rstest]
    #[case(
        "git submodule update unknown",
        "unknown",
        "git add -- unknown && git submodule update unknown"
    )]
    #[case(
        "git commit unknown",
        "unknown",
        "git add -- unknown && git commit unknown"
    )]
    // This is the corrected test case:
    #[case(
        "git commit \"file with spaces.txt\"",
        "file with spaces.txt",
        "git add -- 'file with spaces.txt' && git commit \"file with spaces.txt\""
    )]
    fn test_get_new_command(#[case] script: &str, #[case] target: &str, #[case] expected: &str) {
        let stdout = format!(
            "error: pathspec '{}' did not match any file(s) known to git.",
            target
        );
        let system_shell = Bash {};
        let command = CrabCommand::new(script.to_owned(), Some(stdout), None);

        // The assertion now correctly expects single quotes from shlex in the `git add`
        // part and preserves the original double quotes in the `git commit` part.
        assert_eq!(
            mockable_get_new_command(&command, Some(&system_shell), Some(true))[0],
            expected
        );
    }
}

// FILE: ./src/rules/git_two_dashes.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
    utils::replace_argument,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        stdout.contains("error: did you mean `") && stdout.contains("` (with two dashes ?)")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(stdout) = &command.output {
        if let Some(to) = &stdout.split('`').nth(1) {
            return vec![replace_argument(&command.script, &to[1..], to)];
        }
    }
    vec![]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_two_dashes".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case(
        "git add -patch",
        "error: did you mean `--patch` (with two dashes ?)",
        true
    )]
    #[case(
        "git checkout -patch",
        "error: did you mean `--patch` (with two dashes ?)",
        true
    )]
    #[case(
        "git commit -amend",
        "error: did you mean `--amend` (with two dashes ?)",
        true
    )]
    #[case(
        "git push -tags",
        "error: did you mean `--tags` (with two dashes ?)",
        true
    )]
    #[case(
        "git rebase -continue",
        "error: did you mean `--continue` (with two dashes ?)",
        true
    )]
    #[case("git add --patch", "", false)]
    #[case("git checkout --patch", "", false)]
    #[case("git commit --amend", "", false)]
    #[case("git push --tags", "", false)]
    #[case("git rebase --continue", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git add -patch", "error: did you mean `--patch` (with two dashes ?)", vec!["git add --patch"])]
    #[case("git checkout -patch", "error: did you mean `--patch` (with two dashes ?)", vec!["git checkout --patch"])]
    #[case("git commit -amend", "error: did you mean `--amend` (with two dashes ?)", vec!["git commit --amend"])]
    #[case("git push -tags", "error: did you mean `--tags` (with two dashes ?)", vec!["git push --tags"])]
    #[case("git rebase -continue", "error: did you mean `--continue` (with two dashes ?)", vec!["git rebase --continue"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/npm_missing_script.rs
use super::{
    utils::{match_rule_with_is_app, npm::is_npm_available},
    Rule,
};
use crate::{
    cli::command::CrabCommand,
    rules::utils::npm::{mockable_get_scripts, run_npm_command},
    shell::Shell,
    utils::replace_command,
};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command
            .script_parts
            .iter()
            .any(|part| part.starts_with("ru"))
            && output.contains("npm ERR! missing script: ")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["npm"], None)
}

pub fn mockable_get_new_command<F>(command: &mut CrabCommand, fn_get_scripts: F) -> Vec<String>
where
    F: Fn() -> Vec<u8>,
{
    if let Some(output) = &command.output {
        let re = Regex::new(r".*missing script: (.*)\n").unwrap();
        if let Some(caps) = re.captures(output) {
            println!("{caps:?}");
            replace_command(
                command,
                &caps[1],
                mockable_get_scripts(fn_get_scripts)
                    .iter()
                    .map(|s| s.as_str())
                    .collect(),
            )
        } else {
            vec![]
        }
    } else {
        vec![]
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    mockable_get_new_command(command, run_npm_command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "npm_missing_script".to_owned(),
        Some(is_npm_available()),
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{match_rule, mockable_get_new_command};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    fn output(script: &str) -> String {
        format!(
            r#"
npm ERR! Linux 4.4.0-31-generic
npm ERR! argv "/opt/node/bin/node" "/opt/node/bin/npm" "run" "dvelop"
npm ERR! node v4.4.7
npm ERR! npm  v2.15.8

npm ERR! missing script: {script}
npm ERR!
npm ERR! If you need help, you may report this error at:
npm ERR!     <https://github.com/npm/npm/issues>

npm ERR! Please include the following file with any support request:
npm ERR!     /home/nvbn/exp/code_view/client_web/npm-debug.log
"#
        )
    }
    #[rstest]
    #[case("npm ru wach", &output("wach"), true)]
    #[case("npm run live-tes", &output("live-tes"), true)]
    #[case("npm run-script sahare", &output("sahare"), true)]
    #[case("npm wach", &output("wach"), false)]
    #[case("vim live-tes", &output("live-tes"), false)]
    #[case("npm run-script sahare", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("npm ru wach-tests", &output("wach-tests"), vec!["npm ru watch-test"])]
    #[case("npm -i run-script dvelop", &output("dvelop"), vec!["npm -i run-script develop", "npm -i run-script build"])]
    #[case("npm -i run-script buld -X POST", &output("buld"), vec!["npm -i run-script build -X POST", "npm -i run-script develop -X POST"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let run_script_stdout = b"
Lifecycle scripts included in code-view-web:
  test
    jest

available via `npm run-script`:
  build
    cp node_modules/ace-builds/src-min/ -a resources/ace/ && webpack --progress --colors -p --config ./webpack.production.config.js
  develop
    cp node_modules/ace-builds/src/ -a resources/ace/ && webpack-dev-server --progress --colors
  watch-test
    jest --verbose --watch

";
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(
            mockable_get_new_command(&mut command, || run_script_stdout.to_vec()),
            expected
        );
    }
}

// FILE: ./src/rules/apt_upgrade.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use super::{match_rule_without_sudo, Rule};

fn _match_rule(command: &CrabCommand) -> bool {
    (command.script == "apt list --upgradable") & {
        if let Some(stdout) = &command.output {
            stdout.trim().split('\n').count() > 1
        } else {
            false
        }
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(_match_rule, command)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec!["apt upgrade".to_owned()]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "apt_upgrade".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{_match_rule, match_rule};
    use crate::cli::command::CrabCommand;

    #[test]
    fn test_match_rule() {
        assert!(_match_rule(&CrabCommand::new(
            "apt list --upgradable".to_owned(),
            Some("multiple\nlines".to_owned()),
            None
        )));
        assert!(!_match_rule(&CrabCommand::new(
            "sudo apt list --upgradable".to_owned(),
            Some("multiple\nlines".to_owned()),
            None
        )));
        assert!(match_rule(
            &mut CrabCommand::new(
                "sudo apt list --upgradable".to_owned(),
                Some("multiple\nlines".to_owned()),
                None
            ),
            None
        ));
    }
}

// FILE: ./src/rules/javac.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    command.script_parts.first().is_some_and(|s| s == "javac") && !command.script.ends_with(".java")
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["javac"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![format!("{}.java", command.script)]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "javac".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("javac foo", "", true)]
    #[case("javac bar", "", true)]
    #[case("javac foo.java", "", false)]
    #[case("javac bar.java", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("javac foo", "", vec!["javac foo.java"])]
    #[case("javac bar", "", vec!["javac bar.java"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/man_no_space.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell};

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(output) = &command.output {
        command.script.starts_with("man") && output.contains("command not found")
    } else {
        false
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![format!("man {}", &command.script[3..])]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "man_no_space".to_owned(),
        None,
        Some(2000),
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("mandiff", "mandiff: command not found", true)]
    #[case("", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("mandiff", "", vec!["man diff"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_clone_missing.rs
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

use which::which;

use super::Rule;

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    let stdout = command.output.clone().unwrap_or("".to_owned());
    if command.script_parts.len() != 1
        || which(&command.script_parts[0]).is_ok()
        || !(stdout.contains("No such file or directory")
            || stdout.contains("not found")
            || stdout.contains("is not recognised as"))
    {
        false
    } else {
        let re =
            Regex::new(r"((git|ssh|http(s)?)|(git@[\w\.]+))(:(//)?)([\w\.@\:/\-~]+)(\.git)?(/)?")
                .unwrap();
        re.is_match(&command.script)
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![format!("git clone {}", command.script)]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_clone_missing".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use crate::{parameterized_get_new_command_tests, parameterized_match_rule_tests};

    parameterized_match_rule_tests! {
        match_rule,
        match_rule_01: ("https://github.com/nvbn/thefuck.git", "No such file or directory", true),
        match_rule_02: ("https://github.com/nvbn/thefuck.git", "not found", true),
        match_rule_03: ("https://github.com/nvbn/thefuck.git", "is not recognised as", true),
        match_rule_04: ("https://github.com/nvbn/thefuck", "No such file or directory", true),
        match_rule_05: ("https://github.com/nvbn/thefuck", "not found", true),
        match_rule_06: ("https://github.com/nvbn/thefuck", "is not recognised as", true),
        match_rule_07: ("http://github.com/nvbn/thefuck.git", "No such file or directory", true),
        match_rule_08: ("http://github.com/nvbn/thefuck.git", "not found", true),
        match_rule_09: ("http://github.com/nvbn/thefuck.git", "is not recognised as", true),
        match_rule_10: ("git@github.com:nvbn/thefuck.git", "No such file or directory", true),
        match_rule_11: ("git@github.com:nvbn/thefuck.git", "not found", true),
        match_rule_12: ("git@github.com:nvbn/thefuck.git", "is not recognised as", true),
        match_rule_13: ("git@github.com:nvbn/thefuck", "No such file or directory", true),
        match_rule_14: ("git@github.com:nvbn/thefuck", "not found", true),
        match_rule_15: ("git@github.com:nvbn/thefuck", "is not recognised as", true),
        match_rule_16: ("ssh://git@github.com:nvbn/thefuck.git", "No such file or directory", true),
        match_rule_17: ("ssh://git@github.com:nvbn/thefuck.git", "not found", true),
        unmatch_rule_01: ("", "No such file or directory", false),
        unmatch_rule_02: ("", "not found", false),
        unmatch_rule_03: ("", "is not recognised as", false),
        unmatch_rule_04: ("", "some other output", false),
        unmatch_rule_05: ("notacommand", "No such file or directory", false),
        unmatch_rule_06: ("notacommand", "not found", false),
        unmatch_rule_07: ("notacommand", "is not recognised as", false),
        unmatch_rule_08: ("notacommand", "some other output", false),
        unmatch_rule_09: ("ssh git@github.com:nvbn/thefrick.git", "No such file or directory", false),
        unmatch_rule_10: ("ssh git@github.com:nvbn/thefrick.git", "not found", false),
        unmatch_rule_11: ("ssh git@github.com:nvbn/thefrick.git", "is not recognised as", false),
        unmatch_rule_12: ("ssh git@github.com:nvbn/thefrick.git", "some other output", false),
        unmatch_rule_13: ("git clone foo", "No such file or directory", false),
        unmatch_rule_14: ("git clone foo", "not found", false),
        unmatch_rule_15: ("git clone foo", "is not recognised as", false),
        unmatch_rule_16: ("git clone foo", "some other output", false),
        unmatch_rule_17: ("git clone https://github.com/nvbn/thefuck.git", "No such file or directory", false),
        unmatch_rule_18: ("git clone https://github.com/nvbn/thefuck.git", "not found", false),
        unmatch_rule_19: ("git clone https://github.com/nvbn/thefuck.git", "is not recognised as", false),
        unmatch_rule_20: ("git clone https://github.com/nvbn/thefuck.git", "some other output", false),
        unmatch_rule_21: ("github.com/nvbn/thefuck.git", "No such file or directory", false),
        unmatch_rule_22: ("github.com/nvbn/thefuck.git", "not found", false),
        unmatch_rule_23: ("github.com/nvbn/thefuck.git", "is not recognised as", false),
        unmatch_rule_24: ("github.com/nvbn/thefuck.git", "some other output", false),
        unmatch_rule_25: ("github.com:nvbn/thefuck.git", "No such file or directory", false),
        unmatch_rule_26: ("github.com:nvbn/thefuck.git", "not found", false),
        unmatch_rule_27: ("github.com:nvbn/thefuck.git", "is not recognised as", false),
        unmatch_rule_28: ("github.com:nvbn/thefuck.git", "some other output", false),
        unmatch_rule_29: ("git clone git clone ssh://git@github.com:nvbn/thefrick.git", "No such file or directory", false),
        unmatch_rule_30: ("git clone git clone ssh://git@github.com:nvbn/thefrick.git", "not found", false),
        unmatch_rule_31: ("git clone git clone ssh://git@github.com:nvbn/thefrick.git", "is not recognised as", false),
        unmatch_rule_32: ("git clone git clone ssh://git@github.com:nvbn/thefrick.git", "some other output", false),
    }

    parameterized_get_new_command_tests! {
        get_new_command,
        get_new_command_01: ("https://github.com/nvbn/thefuck.git", "No such file or directory", "git clone https://github.com/nvbn/thefuck.git"),
        get_new_command_02: ("https://github.com/nvbn/thefuck.git", "not found", "git clone https://github.com/nvbn/thefuck.git"),
        get_new_command_03: ("https://github.com/nvbn/thefuck.git", "is not recognised as", "git clone https://github.com/nvbn/thefuck.git"),
        get_new_command_04: ("https://github.com/nvbn/thefuck", "No such file or directory", "git clone https://github.com/nvbn/thefuck"),
        get_new_command_05: ("https://github.com/nvbn/thefuck", "not found", "git clone https://github.com/nvbn/thefuck"),
        get_new_command_06: ("https://github.com/nvbn/thefuck", "is not recognised as", "git clone https://github.com/nvbn/thefuck"),
        get_new_command_07: ("http://github.com/nvbn/thefuck.git", "No such file or directory", "git clone http://github.com/nvbn/thefuck.git"),
        get_new_command_08: ("http://github.com/nvbn/thefuck.git", "not found", "git clone http://github.com/nvbn/thefuck.git"),
        get_new_command_09: ("http://github.com/nvbn/thefuck.git", "is not recognised as", "git clone http://github.com/nvbn/thefuck.git"),
        get_new_command_10: ("git@github.com:nvbn/thefuck.git", "No such file or directory", "git clone git@github.com:nvbn/thefuck.git"),
        get_new_command_11: ("git@github.com:nvbn/thefuck.git", "not found", "git clone git@github.com:nvbn/thefuck.git"),
        get_new_command_12: ("git@github.com:nvbn/thefuck.git", "is not recognised as", "git clone git@github.com:nvbn/thefuck.git"),
        get_new_command_13: ("git@github.com:nvbn/thefuck", "No such file or directory", "git clone git@github.com:nvbn/thefuck"),
        get_new_command_14: ("git@github.com:nvbn/thefuck", "not found", "git clone git@github.com:nvbn/thefuck"),
        get_new_command_15: ("git@github.com:nvbn/thefuck", "is not recognised as", "git clone git@github.com:nvbn/thefuck"),
        get_new_command_16: ("ssh://git@github.com:nvbn/thefuck.git", "No such file or directory", "git clone ssh://git@github.com:nvbn/thefuck.git"),
        get_new_command_17: ("ssh://git@github.com:nvbn/thefuck.git", "not found", "git clone ssh://git@github.com:nvbn/thefuck.git"),
        get_new_command_18: ("ssh://git@github.com:nvbn/thefuck.git", "is not recognised as", "git clone ssh://git@github.com:nvbn/thefuck.git"),
    }
}

// FILE: ./src/rules/git_fix_stash.rs
use super::{utils::git::get_new_command_with_git_support, Rule};
use crate::utils::replace_argument;
use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
    utils::get_closest,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script_parts.len() > 1
            && command.script_parts[1] == "stash"
            && stdout.contains("usage:")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if command.script_parts.len() > 2 {
        let stash_commands = vec![
            "apply", "branch", "clear", "drop", "list", "pop", "save", "show",
        ];
        let stash_cmd = &command.script_parts[2];
        let fixed = get_closest(stash_cmd, &stash_commands, None, Some(false));

        if let Some(fixed) = fixed {
            vec![replace_argument(&command.script, stash_cmd, fixed)]
        } else {
            let mut cmd = command.script_parts.clone();
            cmd.insert(2, "save".to_owned());
            vec![cmd.join(" ")]
        }
    } else {
        Vec::<String>::new()
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_fix_stash".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const GIT_STASH_ERR: &str = "\
usage: git stash list [<options>]
   or: git stash show [<stash>]
   or: git stash drop [-q|--quiet] [<stash>]
   or: git stash ( pop | apply ) [--index] [-q|--quiet] [<stash>]
   or: git stash branch <branchname> [<stash>]
   or: git stash [save [--patch] [-k|--[no-]keep-index] [-q|--quiet]
\t\t       [-u|--include-untracked] [-a|--all] [<message>]]
   or: git stash clear
";

    #[rstest]
    #[case("git stash opp", GIT_STASH_ERR, true)]
    #[case("git stash Some message", GIT_STASH_ERR, true)]
    #[case("git stash saev Some message", GIT_STASH_ERR, true)]
    #[case("git", GIT_STASH_ERR, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git stash opp", GIT_STASH_ERR, vec!["git stash pop"])]
    #[case("git stash Some message", GIT_STASH_ERR, vec!["git stash save Some message"])]
    #[case("git stash saev Some message", GIT_STASH_ERR, vec!["git stash save Some message"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_stash_pop.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("stash")
            && command.script.contains("pop")
            && stdout
                .contains("Your local changes to the following files would be overwritten by merge")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![system_shell
        .unwrap()
        .and(vec!["git add --update", "git stash pop", "git reset ."])]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_stash_pop".to_owned(),
        None,
        Some(900), // priority
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const OUTPUT: &str =
        "error: Your local changes to the following files would be overwritten by merge:";

    #[rstest]
    #[case("git stash pop", OUTPUT, true)]
    #[case("git stash", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git stash pop", OUTPUT, vec!["git add --update && git stash pop && git reset ."])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/git_rm_staged.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        return command.script.contains(" rm ")
            && output.contains("error: the following file has changes staged in the index")
            && output.contains("use --cached to keep the file, or -f to force removal");
    }
    false
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    let mut command_parts = command.script_parts.clone();
    if let Some(index) = command_parts.iter().position(|r| r == "rm") {
        command_parts.insert(index + 1, "--cached".to_string());
        let mut command_list = vec![command_parts.join(" ")];
        command_parts[index + 1] = "-f".to_string();
        command_list.push(command_parts.join(" "));
        return command_list;
    }
    vec![]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_rm_staged".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    fn output(target: &str) -> String {
        format!("error: the following file has changes staged in the index:\n    {target}\n(use --cached to keep the file, or -f to force removal)")
    }

    #[rstest]
    #[case("git rm foo", &output("foo"), true)]
    #[case("git rm foo bar", &output("bar"), true)]
    #[case("git rm foo", "", false)]
    #[case("git rm foo bar", "", false)]
    #[case("git rm", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git rm foo", &output("foo"), vec!["git rm --cached foo", "git rm -f foo"])]
    #[case("git rm foo bar", &output("bar"), vec!["git rm --cached foo bar", "git rm -f foo bar"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/git_clone.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command.script.contains(" git clone ") && output.contains("fatal: Too many arguments.")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, _system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![command.script.replacen(" git clone ", " ", 1)]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_clone_git_clone".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const OUTPUT_CLEAN: &str = "\
fatal: Too many arguments.\n\n\
usage: git clone [<options>] [--] <repo> [<dir>]\n";

    #[rstest]
    #[case("git clone git clone foo", OUTPUT_CLEAN, true)]
    #[case("git clone foo", "", false)]
    #[case("git clone foo bar baz", OUTPUT_CLEAN, false)]
    #[case("git branch", "", false)]
    #[case("", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git clone git clone foo", OUTPUT_CLEAN, vec!["git clone foo"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(
            get_new_command(&mut command, Some(&system_shell)),
            expected.iter().map(|&s| s.to_owned()).collect::<Vec<_>>()
        );
    }
}

// FILE: ./src/rules/gradle_wrapper.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use std::path::Path;
use which::which;

fn gradlew_exists() -> bool {
    Path::new("gradlew").exists()
}

fn is_terminal_command(terminal_command: &str) -> bool {
    which(terminal_command).is_ok()
}

fn auxiliary_match_rule<F, G>(
    command: &CrabCommand,
    fn_is_terminal_command: F,
    fn_file_exists: G,
) -> bool
where
    F: Fn(&str) -> bool,
    G: Fn() -> bool,
{
    if let Some(output) = &command.output {
        !fn_is_terminal_command(&command.script_parts[0])
            && output.contains("not found")
            && fn_file_exists()
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(
        |command| auxiliary_match_rule(command, is_terminal_command, gradlew_exists),
        command,
        vec!["gradle"],
        None,
    )
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![format!("./gradlew {}", command.script_parts[1..].join(" "))]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "gradle_wrapper".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{auxiliary_match_rule, get_new_command};
    use crate::cli::command::CrabCommand;
    use crate::rules::utils::match_rule_with_is_app;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("gradle tasks", "gradle: not found", false, true, true)]
    #[case("gradle build", "gradle: not found", false, true, true)]
    #[case("gradle tasks", "gradle: not found", false, false, false)]
    #[case("gradle tasks", "command not found", true, true, false)]
    #[case("npm tasks", "npm: not found", false, true, false)]
    fn test_match(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] is_terminal_command: bool,
        #[case] file_exists: bool,
        #[case] is_match: bool,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(
            match_rule_with_is_app(
                |command| auxiliary_match_rule(command, |s| is_terminal_command, || file_exists),
                &command,
                vec!["gradle"],
                None,
            ),
            is_match
        );
    }

    #[rstest]
    #[case("gradle assemble", "", vec!["./gradlew assemble"])]
    #[case("gradle --help", "", vec!["./gradlew --help"])]
    #[case("gradle build -c", "", vec!["./gradlew build -c"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_branch_0flag.rs
use super::{utils::git::get_new_command_with_git_support, Rule};
use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
};

fn first_0flag(script_parts: &[String]) -> Option<&String> {
    script_parts
        .iter()
        .find(|p| p.len() == 2 && p.starts_with('0'))
}

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    command.script_parts.get(1) == Some(&"branch".to_owned())
        && first_0flag(&command.script_parts).is_some()
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(branch_name) = first_0flag(&command.script_parts) {
        let fixed_flag = branch_name.replace('0', "-");
        let fixed_script = command.script.replace(branch_name, &fixed_flag);
        if let Some(stdout) = &command.output {
            if stdout.contains("A branch named '") && stdout.contains("' already exists.") {
                let delete_branch = format!("git branch -D {branch_name}");
                vec![delete_branch, fixed_script]
            } else {
                vec![fixed_script]
            }
        } else {
            vec![fixed_script]
        }
    } else {
        Vec::<String>::new()
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_branch_0flag".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}
#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;

    const OUTPUT_BRANCH_EXISTS: &str = "fatal: A branch named 'bar' already exists.";
    const OUTPUT_NOT_VALID_OBJECT: &str = "fatal: Not a valid object name: 'bar'.";

    use rstest::rstest;

    #[rstest]
    #[case("git branch 0a", OUTPUT_BRANCH_EXISTS, true)]
    #[case("git branch 0d", OUTPUT_BRANCH_EXISTS, true)]
    #[case("git branch 0f", OUTPUT_BRANCH_EXISTS, true)]
    #[case("git branch 0r", OUTPUT_BRANCH_EXISTS, true)]
    #[case("git branch 0v", OUTPUT_BRANCH_EXISTS, true)]
    #[case("git branch 0d foo", OUTPUT_BRANCH_EXISTS, true)]
    #[case("git branch 0D foo", OUTPUT_BRANCH_EXISTS, true)]
    #[case("git branch -a", "", false)]
    #[case("git branch -r", "", false)]
    #[case("git branch -v", "", false)]
    #[case("git branch -d foo", "", false)]
    #[case("git branch -D foo", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git branch 0a", OUTPUT_BRANCH_EXISTS, vec!["git branch -D 0a", "git branch -a"])]
    #[case("git branch 0v", OUTPUT_BRANCH_EXISTS, vec!["git branch -D 0v", "git branch -v"])]
    #[case("git branch 0d foo", OUTPUT_BRANCH_EXISTS, vec!["git branch -D 0d", "git branch -d foo"])]
    #[case("git branch 0D foo", OUTPUT_BRANCH_EXISTS, vec!["git branch -D 0D", "git branch -D foo"])]
    #[case("git branch 0l 'maint-*'", OUTPUT_BRANCH_EXISTS, vec!["git branch -D 0l", "git branch -l 'maint-*'"])]
    #[case("git branch 0u upstream", OUTPUT_BRANCH_EXISTS, vec!["git branch -D 0u", "git branch -u upstream"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }

    #[rstest]
    #[case("git branch 0l 'maint-*'", OUTPUT_NOT_VALID_OBJECT, vec!["-l 'maint-*'"])]
    #[case("git branch 0u upstream", OUTPUT_NOT_VALID_OBJECT, vec!["-u upstream"])]
    fn test_get_new_command_not_valid_object(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        let new_command = expected
            .iter()
            .map(|s| format!("git branch {s}"))
            .collect::<Vec<_>>();
        assert_eq!(get_new_command(&mut command, None), new_command);
    }
}

// FILE: ./src/rules/nixos_cmd_not_found.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

fn get_name(command_output: &str) -> Option<String> {
    let re = Regex::new(r"nix-env -iA ([^\s]*)").unwrap();
    re.captures(command_output).map(|caps| caps[1].to_string())
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(output) = &command.output {
        get_name(output).is_some()
    } else {
        false
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(output) = &command.output {
        if let Some(name) = get_name(output) {
            vec![system_shell
                .unwrap()
                .and(vec![&format!("nix-env -iA {name}"), &command.script])]
        } else {
            vec![]
        }
    } else {
        vec![]
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "nixos_cmd_not_found".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("vim", "nix-env -iA nixos.vim", true)]
    #[case("vim", "", false)]
    #[case("", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("vim", "nix-env -iA nixos.vim", vec!["nix-env -iA nixos.vim && vim"])]
    #[case("pacman", "nix-env -iA nixos.pacman", vec!["nix-env -iA nixos.pacman && pacman"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/grep_arguments_order.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use std::path::Path;

fn get_actual_file(parts: &[String]) -> Option<&String> {
    for part in parts.iter().skip(1) {
        let part_path = Path::new(part);
        if part_path.is_file() || part_path.is_dir() {
            return Some(part);
        }
    }
    None
}

fn auxiliary_match_rule<F>(command: &CrabCommand, fn_get_actual_file: F) -> bool
where
    F: Fn(&[String]) -> Option<&String>,
{
    if let Some(output) = &command.output {
        if command.script_parts.len() > 1 {
            output.contains(": No such file or directory")
                && fn_get_actual_file(&command.script_parts).is_some()
        } else {
            false
        }
    } else {
        false
    }
}

fn mockable_match_rule<F>(
    command: &mut CrabCommand,
    fn_get_actual_file: &F,
    system_shell: Option<&dyn Shell>,
) -> bool
where
    F: Fn(&[String]) -> Option<&String>,
{
    match_rule_with_is_app(
        |command| auxiliary_match_rule(command, fn_get_actual_file),
        command,
        vec!["grep", "egrep"],
        None,
    )
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    mockable_match_rule(command, &get_actual_file, system_shell)
}

fn mockable_get_new_command<F>(
    command: &mut CrabCommand,
    fn_get_actual_file: &F,
    system_shell: Option<&dyn Shell>,
) -> Vec<String>
where
    F: Fn(&[String]) -> Option<&String>,
{
    if command.script_parts.len() > 1 {
        if let Some(actual_file) = fn_get_actual_file(&command.script_parts) {
            let mut parts = command.script_parts.clone();
            parts.remove(parts.iter().position(|x| x == actual_file).unwrap());
            parts.push(actual_file.to_string());
            vec![parts.join(" ")]
        } else {
            vec![]
        }
    } else {
        vec![]
    }
}
pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    mockable_get_new_command(command, &get_actual_file, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "grep_arguments_order".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{mockable_get_new_command, mockable_match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;
    use std::path::Path;

    fn mocked_get_actual_file(parts: &[String]) -> Option<&String> {
        for part in parts.iter().skip(1) {
            let part_path = Path::new(part);
            if !part.starts_with('-') || part_path.is_dir() {
                return Some(part);
            }
        }
        None
    }

    #[rstest]
    #[case("grep test.py test", "grep: test: No such file or directory", true)]
    #[case("grep -lir . test", "grep: test: No such file or directory", true)]
    #[case("egrep test.py test", "egrep: test: No such file or directory", true)]
    #[case("egrep -lir . test", "egrep: test: No such file or directory", true)]
    #[case("cat test.py", "cat: test.py: No such file or directory", false)]
    #[case("grep test test.py", "", false)]
    #[case("grep -lir test .", "", false)]
    #[case("egrep test test.py", "", false)]
    #[case("egrep -lir test .", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(
            mockable_match_rule(&mut command, &mocked_get_actual_file, None),
            is_match
        );
    }

    #[rstest]
    #[case("grep test.py test", "grep: test: No such file or directory", vec!["grep test test.py"])]
    #[case("grep -lir . test", "grep: test: No such file or directory", vec!["grep -lir test ."])]
    #[case("grep . test -lir", "grep: test: No such file or directory", vec!["grep test -lir ."])]
    #[case("egrep test.py test", "egrep: test: No such file or directory", vec!["egrep test test.py"])]
    #[case("egrep -lir . test", "egrep: test: No such file or directory", vec!["egrep -lir test ."])]
    #[case("egrep . test -lir", "egrep: test: No such file or directory", vec!["egrep test -lir ."])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(
            mockable_get_new_command(&mut command, &mocked_get_actual_file, None),
            expected
        );
    }
}

// FILE: ./src/rules/choco_install.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use super::Rule;

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(stdout) = &command.output {
        stdout.contains("Installing the following packages")
            && (command.script.starts_with("choco install")
                || command.script_parts.contains(&"cinst".to_owned()))
    } else {
        false
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let reference = ["choco", "cinst", "install"];
    for script_part in &command.script_parts {
        if
        // These are certainly parameters
        !script_part.contains('=') && !script_part.contains('/') &&
            // Leading hyphens are parameters; some packages contain them though
            !script_part.starts_with('-') &&
            // Need exact match (bc chocolatey is a package)
            !reference.contains(&script_part.as_str())
        {
            return vec![command
                .script
                .replace(script_part, &(script_part.to_owned() + ".install"))];
        }
    }
    vec![]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "choco_install".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;

    const PACKAGE_NOT_FOUND_ERROR: &str = r#"Chocolatey v0.10.15
Installing the following packages:
logstitcher
By installing you accept licenses for the packages.
logstitcher not installed. The package was not found with the source(s) listed.
 Source(s): 'https://chocolatey.org/api/v2/'
 NOTE: When you specify explicit sources, it overrides default sources.
If the package version is a prerelease and you didn\'t specify `--pre`,
 the package may not be found.
Please see https://chocolatey.org/docs/troubleshooting for more
 assistance.

Chocolatey installed 0/1 packages. 1 packages failed.
 See the log for details (C:\\ProgramData\\chocolatey\\logs\\chocolatey.log).

Failures
 - logstitcher - logstitcher not installed. The package was not found with the source(s) listed.
 Source(s): 'https://chocolatey.org/api/v2/'
 NOTE: When you specify explicit sources, it overrides default sources.
If the package version is a prerelease and you didn\'t specify `--pre`,
 the package may not be found.
Please see https://chocolatey.org/docs/troubleshooting for more
 assistance.
"#;

    macro_rules! parameterized_match_rule_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert!(match_rule(&mut command, None));
                }
            )*
        }
    }

    macro_rules! parameterized_unmatch_rule_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert!(!match_rule(&mut command, None));
                }
            )*
        }
    }

    macro_rules! parameterized_get_new_command_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout, expected) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert_eq!(get_new_command(&mut command, None)[0], expected);
                }
            )*
        }
    }

    parameterized_match_rule_tests! {
        match_rule_1: ("choco install logstitcher", PACKAGE_NOT_FOUND_ERROR),
        match_rule_2: ("cinst logstitcher", PACKAGE_NOT_FOUND_ERROR),
        match_rule_3: ("choco install logstitcher -y", PACKAGE_NOT_FOUND_ERROR),
        match_rule_4: ("cinst logstitcher -y", PACKAGE_NOT_FOUND_ERROR),
        match_rule_5: ("choco install logstitcher -y -n=test", PACKAGE_NOT_FOUND_ERROR),
        match_rule_6: ("cinst logstitcher -y -n=test", PACKAGE_NOT_FOUND_ERROR),
        match_rule_7: ("choco install logstitcher -y -n=test /env", PACKAGE_NOT_FOUND_ERROR),
        match_rule_8: ("cinst logstitcher -y -n=test /env", PACKAGE_NOT_FOUND_ERROR),
        match_rule_9: ("choco install chocolatey -y", PACKAGE_NOT_FOUND_ERROR),
        match_rule_10: ("cinst chocolatey -y", PACKAGE_NOT_FOUND_ERROR),
    }

    parameterized_unmatch_rule_tests! {
        unmatch_rule_1: ("choco /?", ""),
        unmatch_rule_2: ("choco upgrade logstitcher", ""),
        unmatch_rule_3: ("cup logstitcher", ""),
        unmatch_rule_4: ("choco upgrade logstitcher -y", ""),
        unmatch_rule_5: ("cup logstitcher -y", ""),
        unmatch_rule_6: ("choco upgrade logstitcher -y -n=test", ""),
        unmatch_rule_7: ("cup logstitcher -y -n=test", ""),
        unmatch_rule_8: ("choco upgrade logstitcher -y -n=test /env", ""),
        unmatch_rule_9: ("cup logstitcher -y -n=test /env", ""),
        unmatch_rule_10: ("choco upgrade chocolatey -y", ""),
        unmatch_rule_11: ("cup chocolatey -y", ""),
        unmatch_rule_12: ("choco uninstall logstitcher", ""),
        unmatch_rule_13: ("cuninst logstitcher", ""),
        unmatch_rule_14: ("choco uninstall logstitcher -y", ""),
        unmatch_rule_15: ("cuninst logstitcher -y", ""),
        unmatch_rule_16: ("choco uninstall logstitcher -y -n=test", ""),
        unmatch_rule_17: ("cuninst logstitcher -y -n=test", ""),
        unmatch_rule_18: ("choco uninstall logstitcher -y -n=test /env", ""),
        unmatch_rule_19: ("cuninst logstitcher -y -n=test /env", ""),
        unmatch_rule_20: ("choco uninstall chocolatey -y", ""),
        unmatch_rule_21: ("cuninst chocolatey -y", ""),
    }

    parameterized_get_new_command_tests! {
        get_new_command_1: ("choco install logstitcher", "", "choco install logstitcher.install"),
        get_new_command_2: ("cinst logstitcher", "", "cinst logstitcher.install"),
        get_new_command_3: ("choco install logstitcher -y", "", "choco install logstitcher.install -y"),
        get_new_command_4: ("cinst logstitcher -y", "", "cinst logstitcher.install -y"),
        get_new_command_5: ("choco install logstitcher -y -n=test", "", "choco install logstitcher.install -y -n=test"),
        get_new_command_6: ("cinst logstitcher -y -n=test", "", "cinst logstitcher.install -y -n=test"),
        get_new_command_7: ("choco install logstitcher -y -n=test /env", "", "choco install logstitcher.install -y -n=test /env"),
        get_new_command_8: ("cinst logstitcher -y -n=test /env", "", "cinst logstitcher.install -y -n=test /env"),
        get_new_command_9: ("choco install chocolatey -y", "", "choco install chocolatey.install -y"),
        // get_new_command_10: ("cinst chocolatey -y", "", "cinst chocolatey.install -y"),
    }
}

// FILE: ./src/rules/remove_shell_prompt_literal.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(output) = &command.output {
        let re = Regex::new(r"^[\s]*\$ [\S]+").unwrap();
        output.contains("$: command not found") && re.is_match(&command.script)
    } else {
        false
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command
        .script
        .trim_start_matches(|c: char| c == '$' || c.is_whitespace())
        .to_owned()]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "remove_shell_prompt_literal".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("$ cd newdir", "$: command not found", true)]
    #[case(" $ cd newdir", "$: command not found", true)]
    #[case("$ $ cd newdir", "$: command not found", true)]
    #[case(" $ $ cd newdir", "$: command not found", true)]
    #[case("$", "$: command not found", false)]
    #[case(" $", "$: command not found", false)]
    #[case("$?", "127: command not found", false)]
    #[case(" $?", "127: command not found", false)]
    #[case("", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("$ cd newdir", "", vec!["cd newdir"])]
    #[case("$ $ cd newdir", "", vec!["cd newdir"])]
    #[case("$ python3 -m virtualenv env", "", vec!["python3 -m virtualenv env"])]
    #[case(" $ $ $ python3 -m virtualenv env", "", vec!["python3 -m virtualenv env"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/brew_install.rs
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

use super::Rule;

fn get_suggestions(str: String) -> Vec<String> {
    str.replace(" or ", ", ")
        .split(", ")
        .map(|s| s.to_string())
        .collect()
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("install")
            && stdout.contains("No available formula")
            && stdout.contains("Did you mean")
    } else {
        false
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let re = Regex::new(
        "Warning: No available formula with the name \"(?:[^\"]+)\". Did you mean (.+)\\?",
    )
    .unwrap();
    let stdout = &command.output.as_ref().unwrap();
    let caps = re.captures(stdout).unwrap();
    let suggestions = get_suggestions(caps.get(1).map_or("", |m| m.as_str()).to_owned());
    suggestions
        .iter()
        .map(|formula| format!("brew install {formula}"))
        .collect()
}

pub fn get_rule() -> Rule {
    Rule::new(
        "brew_install".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, get_suggestions, match_rule};
    use crate::cli::command::CrabCommand;

    const BREW_NO_AVAILABLE_FORMULA_ONE: &str =
        "Warning: No available formula with the name \"giss\". Did you mean gist?";
    const BREW_NO_AVAILABLE_FORMULA_TWO: &str = "Warning: No available formula with the name \"elasticserar\". Did you mean elasticsearch or elasticsearch@6?";
    const BREW_NO_AVAILABLE_FORMULA_THREE: &str =
        "Warning: No available formula with the name \"gitt\". Did you mean git, gitg or gist?";
    const BREW_INSTALL_NO_ARGUMENT: &str =
        "Install a formula or cask. Additional options specific to a formula may be";
    const BREW_ALREADY_INSTALLED: &str = "Warning: git-2.3.5 already installed";

    macro_rules! parameterized_match_rule_tests {
        ($match_rule:expr, $($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert!($match_rule(&mut command, None));
                }
            )*
        }
    }

    macro_rules! parameterized_unmatch_rule_tests {
        ($match_rule:expr, $($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert!(!$match_rule(&mut command, None));
                }
            )*
        }
    }

    macro_rules! parameterized_get_new_command_tests {
        ($get_new_command:expr, $($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout, expected, neq) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    if neq{
                        assert_ne!($get_new_command(&mut command, None), expected);
                    }
                    else{
                        assert_eq!($get_new_command(&mut command, None), expected);
                    }
                }
            )*
        }
    }

    parameterized_match_rule_tests! {
        match_rule,
        match_rule_1: ("brew install giss", BREW_NO_AVAILABLE_FORMULA_ONE),
        match_rule_2: ("brew install elasticserar", BREW_NO_AVAILABLE_FORMULA_TWO),
        match_rule_3: ("brew install gitt", BREW_NO_AVAILABLE_FORMULA_THREE),
    }

    parameterized_unmatch_rule_tests! {
        match_rule,
        unmatch_rule_1: ("brew install git", BREW_ALREADY_INSTALLED),
        unmatch_rule_2: ("brew install", BREW_INSTALL_NO_ARGUMENT),
    }

    parameterized_get_new_command_tests! {
        get_new_command,
        get_new_command_1: ("brew install giss", BREW_NO_AVAILABLE_FORMULA_ONE, ["brew install gist"], false),
        get_new_command_2: ("brew install elasticsear", BREW_NO_AVAILABLE_FORMULA_TWO, ["brew install elasticsearch", "brew install elasticsearch@6"], false),
        get_new_command_3: ("brew install gitt", BREW_NO_AVAILABLE_FORMULA_THREE, ["brew install git", "brew install gitg", "brew install gist"], false),
        get_new_command_4: ("brew install aa", BREW_NO_AVAILABLE_FORMULA_ONE, ["brew install aha"], true),
    }

    #[test]
    fn test_suggestions() {
        assert_eq!(get_suggestions("one".to_owned()), ["one"]);
        assert_eq!(get_suggestions("one or two".to_owned()), ["one", "two"]);
        assert_eq!(
            get_suggestions("one, two or three".to_owned()),
            ["one", "two", "three"]
        );
    }
}

// FILE: ./src/rules/conda_mistype.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains("Did you mean 'conda")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["conda"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(output) = &command.output {
        let re = Regex::new(r"'conda ([^']*)'").unwrap();
        let matches = re
            .captures_iter(output)
            .map(|cap| cap[1].to_owned())
            .collect::<Vec<_>>();
        let broken_cmd = matches[0].clone();
        let correct_cmd = matches[1].clone();
        vec![command.script.replace(&broken_cmd, &correct_cmd)]
    } else {
        Vec::<String>::new()
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "conda_mistype".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const MISTYPE_RESPONSE: &str =
        "\n\nCommandNotFoundError: No command 'conda lst'.\nDid you mean 'conda list'?\n\n";

    #[rstest]
    #[case("conda lst", MISTYPE_RESPONSE, true)]
    #[case("codna list", "bash: codna: command not found", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("conda lst", MISTYPE_RESPONSE, vec!["conda list"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_rebase_merge_dir.rs
use super::{utils::git::get_new_command_with_git_support, Rule};
use crate::utils::get_close_matches;

use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("rebase")
            && stdout.contains("It seems that there is already a rebase-merge directory")
            && stdout.contains("I wonder if you are in the middle of another rebase")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(stdout) = &command.output {
        let rm_cmd_split: Vec<&str> = stdout.split('\n').collect();
        if rm_cmd_split.len() > 4 {
            let command_list = vec![
                "git rebase --continue",
                "git rebase --abort",
                "git rebase --skip",
                rm_cmd_split[rm_cmd_split.len() - 4].trim(),
            ];
            get_close_matches(&command.script, &command_list, Some(4), Some(0.))
                .iter()
                .map(|s| s.to_string())
                .collect()
        } else {
            Vec::<String>::new()
        }
    } else {
        Vec::<String>::new()
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_help_aliased".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;

    use rstest::rstest;

    const OUTPUT: &str = "\n\nIt seems that there is already a rebase-merge directory, and\n\
        I wonder if you are in the middle of another rebase.  If that is the\n\
        case, please try\n\tgit rebase (--continue | --abort | --skip)\n\
        If that is not the case, please\n\trm -fr \"/foo/bar/baz/egg/.git/rebase-merge\"\n\
        and run me again.  I am stopping in case you still have something\nvaluable there.\n";

    #[rstest]
    #[case("git rebase master", OUTPUT, true)]
    #[case("git rebase -skip", OUTPUT, true)]
    #[case("git rebase", OUTPUT, true)]
    #[case("git rebase master", "", false)]
    #[case("git rebase -abort", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git rebase master", OUTPUT, vec!["git rebase --abort", "git rebase --skip", "git rebase --continue", "rm -fr \"/foo/bar/baz/egg/.git/rebase-merge\""])]
    #[case("git rebase -skip", OUTPUT, vec!["git rebase --skip", "git rebase --abort", "git rebase --continue", "rm -fr \"/foo/bar/baz/egg/.git/rebase-merge\""])]
    #[case("git rebase", OUTPUT, vec!["git rebase --skip", "git rebase --abort", "git rebase --continue", "rm -fr \"/foo/bar/baz/egg/.git/rebase-merge\""])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_lfs_mistype.rs
use regex::Regex;

use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
    utils::{get_all_matched_commands, replace_command},
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command.script.contains("lfs") && output.contains("Did you mean this?")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(output) = &command.output {
        let re = Regex::new(r#"Error: unknown command "([^"]*)" for "git-lfs""#).unwrap();
        if let Some(caps) = re.captures(output) {
            if let Some(broken_cmd) = caps.get(1) {
                let broken_cmd = broken_cmd.as_str();
                let matched =
                    get_all_matched_commands(output, Some(vec!["Did you mean", " for usage."]));
                return replace_command(
                    command,
                    broken_cmd,
                    matched.iter().map(|s| s.as_str()).collect(),
                );
            }
        }
    }
    vec![]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_lfs_mistype".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const MISTYPE_RESPONSE: &str = "Error: unknown command \"evn\" for \"git-lfs\"\n\nDid you mean this?\n        env\n        ext\n\nRun 'git-lfs --help' for usage.\n";

    #[rstest]
    #[case("git lfs evn", MISTYPE_RESPONSE, true)]
    #[case("git lfs env", "bash: git: command not found", false)]
    #[case("docker lfs env", MISTYPE_RESPONSE, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git lfs evn", MISTYPE_RESPONSE, vec!["git lfs env", "git lfs ext"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/python_execute.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    !&command.script.ends_with(".py")
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["python"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command.script.clone() + ".py"]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "python_execute".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("python foo", "", true)]
    #[case("python bar", "", true)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("python foo", "", vec!["python foo.py"])]
    #[case("python bar", "", vec!["python bar.py"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/no_command.rs
use crate::{
    cli::command::CrabCommand,
    shell::Shell,
    utils::{get_all_executable, get_close_matches},
};
use which::which;

use super::Rule;

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    which(&command.script_parts[0]).is_err()
        & (if let Some(output) = &command.output {
            output.contains("not found") | output.contains("is not recognized as")
        } else {
            false
        })
        & !get_close_matches(
            &command.script_parts[0],
            get_all_executable()
                .iter()
                .map(|s| s.as_str())
                .collect::<Vec<&str>>()
                .as_slice(),
            None,
            None,
        )
        .is_empty()
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let old_command = &command.script_parts[0];
    let old_parameters = {
        if command.script_parts.len() > 1 {
            " ".to_string() + &command.script_parts[1..].join(" ")
        } else {
            "".to_owned()
        }
    };

    // TODO: Check shell history
    let mut new_cmds: Vec<&str> = vec![];
    let executables = get_all_executable();
    let str_executables = executables
        .iter()
        .map(|s| s.as_str())
        .collect::<Vec<&str>>();
    for cmd in get_close_matches(old_command, &str_executables, None, None) {
        if !new_cmds.contains(&cmd) {
            new_cmds.push(cmd);
        }
    }
    new_cmds
        .iter()
        .map(|s| s.to_string() + &old_parameters)
        .collect()
}

pub fn get_rule() -> Rule {
    Rule::new(
        "no_command".to_owned(),
        None,
        Some(3000),
        None,
        match_rule,
        get_new_command,
        None,
    )
}

// FILE: ./src/rules/heroku_not_command.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains("Run heroku _ to run")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["heroku"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let re = Regex::new(r"Run heroku _ to run ([^.]*)").unwrap();
    let new_cmd = re
        .captures(command.output.as_ref().unwrap())
        .unwrap()
        .get(1)
        .map_or("", |m| m.as_str());
    vec![new_cmd.to_owned()]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "heroku_not_command".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}
#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const SUGGEST_OUTPUT: &str = "\n ▸    log is not a heroku command.\n ▸    Perhaps you meant logs?\n ▸    Run heroku _ to run heroku logs.\n ▸    Run heroku help for a list of available commands.";

    #[rstest]
    #[case("heroku log", SUGGEST_OUTPUT, true)]
    #[case("cat log", SUGGEST_OUTPUT, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("heroku log", SUGGEST_OUTPUT, vec!["heroku logs"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/fix_alt_space.rs
use super::{match_rule_without_sudo, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.to_lowercase().contains("command not found") && command.script.contains('\u{00A0}')
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(auxiliary_match_rule, command)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command.script.replace('\u{00A0}', " ")]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "fix_alt_space".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case(
        "ps -ef |\u{00A0}grep foo",
        "-bash: \u{00A0}grep: command not found",
        true
    )]
    #[case("ps -ef | grep foo", "", false)]
    #[case("", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("ps -ef |\u{00A0}grep foo", "", vec!["ps -ef | grep foo"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_tag_force.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command.script_parts.contains(&"tag".to_string()) && output.contains("already exists")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    let new_script = command.script.replacen("tag", "tag --force", 1);
    vec![new_script]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_tag_force".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("git tag alert", "fatal: tag 'alert' already exists", true)]
    #[case("git tag alert", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git tag alert", "fatal: tag 'alert' already exists", vec!["git tag --force alert"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/has_exists_script.rs
use super::{get_new_command_without_sudo, match_rule_without_sudo, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use std::path::Path;

fn file_exists(path: &str) -> bool {
    Path::new(path).exists()
}

fn auxiliary_match_rule<F>(command: &CrabCommand, fn_file_exists: F) -> bool
where
    F: Fn(&str) -> bool,
{
    if let Some(output) = &command.output {
        output.contains("command not found")
            && command
                .script_parts
                .first()
                .is_some_and(|s| fn_file_exists(s))
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(
        |command| auxiliary_match_rule(command, file_exists),
        command,
    )
}

pub fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    vec![format!("./{}", command.script)]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "has_exists_script".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{auxiliary_match_rule, get_new_command};
    use crate::cli::command::CrabCommand;
    use crate::rules::match_rule_without_sudo;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("main", "main: command not found", true, true)]
    #[case("main --help", "main: command not found", true, true)]
    #[case("main", "", true, false)]
    fn test_match(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] file_exists: bool,
        #[case] is_match: bool,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(
            match_rule_without_sudo(
                |command| auxiliary_match_rule(command, |s| file_exists),
                &mut command
            ),
            is_match
        );
    }

    #[rstest]
    #[case("main --help", "", vec!["./main --help"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/brew_reinstall.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        let warning_regex = Regex::new(r"Warning: .+ is already installed and up-to-date").unwrap();
        let message_regex = Regex::new(r"To reinstall .+, run `brew reinstall [^`]+`").unwrap();
        command.script.contains("install")
            && warning_regex.is_match(output)
            && message_regex.is_match(output)
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["brew"], Some(2))
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command.script.replace("install", "reinstall")]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "brew_reinstall".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}
#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const OUTPUT: &str = "Warning: thefuck 9.9 is already installed and up-to-date\nTo reinstall 9.9, run `brew reinstall thefuck`";

    #[rstest]
    #[case("brew install thefuck", OUTPUT, true)]
    #[case("brew reinstall thefuck", "", false)]
    #[case("brew install foo", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("brew install foo", OUTPUT, vec!["brew reinstall foo"])]
    #[case("brew install bar zap", OUTPUT, vec!["brew reinstall bar zap"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/cd_parent.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use super::Rule;

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    command.script == "cd.."
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec!["cd ..".to_owned()]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "cd_parent".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;

    macro_rules! parameterized_match_rule_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert!(match_rule(&mut command, None));
                }
            )*
        }
    }

    macro_rules! parameterized_unmatch_rule_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert!(!match_rule(&mut command, None));
                }
            )*
        }
    }

    macro_rules! parameterized_get_new_command_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout, expected) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert_eq!(get_new_command(&mut command, None)[0], expected);
                }
            )*
        }
    }

    parameterized_match_rule_tests! {
        match_rule_1: ("cd..", "cd..: command not found"),
    }

    parameterized_unmatch_rule_tests! {
        unmatch_rule_1: ("", ""),
    }

    parameterized_get_new_command_tests! {
        get_new_command_1: ("cd..", "", "cd .."),
    }
}

// FILE: ./src/rules/apt_get_search.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use super::Rule;

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    command.script.starts_with("apt-get search")
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec!["apt-cache".to_owned() + &command.script[7..]]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "apt_get_search".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;

    macro_rules! parameterized_match_rule_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert!(match_rule(&mut command, None));
                }
            )*
        }
    }

    macro_rules! parameterized_unmatch_rule_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert!(!match_rule(&mut command, None));
                }
            )*
        }
    }

    macro_rules! parameterized_get_new_command_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, expected) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some("".to_owned()),
                                None
                            );
                    assert_eq!(get_new_command(&mut command, None)[0], expected);
                }
            )*
        }
    }

    parameterized_match_rule_tests! {
        match_rule_1: ("apt-get search foo", ""),
    }

    parameterized_unmatch_rule_tests! {
        unmatch_rule_1: ("ag foo", ""),
        unmatch_rule_2: ("apt-cache search foo", ""),
        unmatch_rule_3: ("aptitude search foo", ""),
        unmatch_rule_4: ("apt search foo", ""),
        unmatch_rule_5: ("apt-get install foo", ""),
        unmatch_rule_6: ("apt-get source foo", ""),
        unmatch_rule_7: ("apt-get clean", ""),
        unmatch_rule_8: ("apt-get remove", ""),
        unmatch_rule_9: ("apt-get update", ""),
    }

    parameterized_get_new_command_tests! {
        get_new_command_1: ("apt-get search foo", "apt-cache search foo"),
    }
}

// FILE: ./src/rules/dry.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell};

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    command.script_parts.len() >= 2 && command.script_parts[0] == command.script_parts[1]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command.script_parts[1..].join(" ")]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "dry".to_owned(),
        None,
        Some(900),
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("cd cd foo", "", true)]
    #[case("git git push origin/master", "", true)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("cd cd foo", "", vec!["cd foo"])]
    #[case("git git push origin/master", "", vec!["git push origin/master"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/quotation_marks.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell};

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    command.script.contains('\'') && command.script.contains('\"')
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command.script.replace('\'', "\"")]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "quotation_marks".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}
#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("git commit -m 'My Message\"", "", true)]
    #[case("git commit -am \"Mismatched Quotation Marks'", "", true)]
    #[case("echo \"hello'", "", true)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git commit -m 'My Message\"", "", vec!["git commit -m \"My Message\""])]
    #[case("git commit -am \"Mismatched Quotation Marks'", "", vec!["git commit -am \"Mismatched Quotation Marks\""])]
    #[case("echo \"hello'", "", vec!["echo \"hello\""])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/heroku_multiple_apps.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains("https://devcenter.heroku.com/articles/multiple-environments")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["heroku"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(output) = &command.output {
        let re = Regex::new(r"([^ ]*) \([^)]*\)").unwrap();
        let apps = re
            .captures_iter(output)
            .map(|cap| cap[1].to_owned())
            .collect::<Vec<_>>();
        println!("{apps:?}");
        println!("{output:?}");
        apps.iter()
            .map(|app| format!("{} --app {}", command.script, app))
            .collect()
    } else {
        Vec::<String>::new()
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "heroku_multiple_apps".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}
#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const SUGGEST_OUTPUT: &str = r#"
 ▸    Multiple apps in git remotes
 ▸    Usage: --remote heroku-dev
 ▸    or: --app myapp-dev
 ▸    Your local git repository has more than 1 app referenced in git remotes.
 ▸    Because of this, we can't determine which app you want to run this command against.
 ▸    Specify the app you want with --app or --remote.
 ▸    Heroku remotes in repo:
 ▸    myapp (heroku)
 ▸    myapp-dev (heroku-dev)
 ▸
 ▸    https://devcenter.heroku.com/articles/multiple-environments
    "#;

    const NOT_MATCH_OUTPUT: &str = r#"
=== HEROKU_POSTGRESQL_TEAL_URL, DATABASE_URL
Plan:                  Hobby-basic
Status:                Available
Connections:           20/20
PG Version:            9.6.4
Created:               2017-01-01 00:00 UTC
Data Size:             99.9 MB
Tables:                99
Rows:                  12345/10000000 (In compliance)
Fork/Follow:           Unsupported
Rollback:              Unsupported
Continuous Protection: Off
Add-on:                postgresql-round-12345
    "#;

    #[rstest]
    #[case("heroku pg", SUGGEST_OUTPUT, true)]
    #[case("heroku pg", NOT_MATCH_OUTPUT, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("heroku pg", SUGGEST_OUTPUT, vec!["heroku pg --app myapp", "heroku pg --app myapp-dev"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/ag_literal.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use super::Rule;

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(output) = &command.output {
        output.ends_with("run ag with -Q\n")
    } else {
        false
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command.script.replacen("ag", "ag -Q", 1)]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "ag_literal".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const STDERR: &str = "ERR: Bad regex! pcre_compile() failed at position 1: missing )\n\
        If you meant to search for a literal string, run ag with -Q\n";

    #[rstest]
    #[case("ag \\(", STDERR, true)]
    #[case("ag foo", "", false)]
    fn test_match(#[case] command: &str, #[case] stderr: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), None, Some(stderr.to_owned()));
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("ag \\(", vec!["ag -Q \\("])]
    fn test_get_new_command(#[case] command: &str, #[case] expected: Vec<&str>) {
        let mut command = CrabCommand::new(command.to_owned(), None, Some(STDERR.to_owned()));
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_pull.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("pull") && stdout.contains("set-upstream")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(stdout) = &command.output {
        let lines: Vec<&str> = stdout.lines().collect();
        let line = lines[lines.len() - 3].trim();

        let words: Vec<&str> = line.split_whitespace().collect();
        let branch = words.last().unwrap_or(&"");
        let set_upstream = line
            .replace("<remote>", "origin")
            .replace("<branch>", branch);
        vec![system_shell
            .unwrap()
            .and(vec![&set_upstream, &command.script])]
    } else {
        Vec::<String>::new()
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_pull".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::{cli::command::CrabCommand, shell::Bash};
    use rstest::rstest;

    const OUTPUT: &str = r#"There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details

    git pull <remote> <branch>

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=<remote>/<branch> master


"#;

    #[rstest]
    #[case("git pull", OUTPUT, true)]
    #[case("git pull", "", false)]
    #[case("ls", OUTPUT, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git pull", OUTPUT, vec!["git branch --set-upstream-to=origin/master master && git pull"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/apt_get.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use which::which;

use super::Rule;

fn get_executable(command: &CrabCommand) -> &str {
    if command.script_parts[0] == "sudo" {
        &command.script_parts[1]
    } else {
        &command.script_parts[0]
    }
}

fn _match_rule(
    command: &mut CrabCommand,
    system_shell: Option<&dyn Shell>,
    mock_which: Option<bool>,
) -> bool {
    if let Some(stdout) = &command.output {
        if stdout.contains("not found") || stdout.contains("not installed") {
            if let Some(which_return) = mock_which {
                !which_return
            } else {
                which(get_executable(command)).is_err()
            }
        } else {
            false
        }
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    _match_rule(command, system_shell, None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let executable = get_executable(command);
    vec![system_shell.unwrap().and(vec![
        &("sudo apt-get install ".to_owned() + executable),
        &command.script,
    ])]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "apt_get".to_owned(),
        None,
        Some(4000),
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{_match_rule, get_new_command};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("vim", "vim: command not found", None, true)]
    #[case("sudo vim", "vim: command not found", None, true)]
    #[case("vim", "The program \"vim\" is currently not installed. You can install it by typing: sudo apt install vim", None, true)]
    #[case("", "", Some(false), false)]
    #[case("vim", "", Some(false), false)]
    #[case("vim", "vim: command not found", Some(true), false)]
    #[case("sudo vim", "vim: command not found", Some(true), false)]
    fn test_match_rule(
        #[case] script: &str,
        #[case] stdout: &str,
        #[case] mock_which: Option<bool>,
        #[case] expected: bool,
    ) {
        let mut command = CrabCommand::new(script.to_owned(), Some(stdout.to_owned()), None);
        // For matching cases, we need to mock `which` to return an error.
        let mock_which_result = if expected { Some(false) } else { mock_which };
        assert_eq!(_match_rule(&mut command, None, mock_which_result), expected);
    }

    #[rstest]
    #[case("vim", "", "sudo apt-get install vim && vim")]
    #[case("git init", "", "sudo apt-get install git && git init")]
    #[case("sudo vim", "", "sudo apt-get install vim && sudo vim")]
    #[case("sudo git init", "", "sudo apt-get install git && sudo git init")]
    fn test_get_new_command(#[case] script: &str, #[case] stdout: &str, #[case] expected: &str) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(script.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(
            get_new_command(&mut command, Some(&system_shell))[0],
            expected
        );
    }
}

// FILE: ./src/rules/cargo_no_command.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command.script_parts.get(1).is_some()
            && output.to_lowercase().contains("no such subcommand")
            && output.contains("Did you mean")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["cargo"], Some(1))
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let re = Regex::new(r"Did you mean `([^`]*)`").unwrap();
    let broken = command.script_parts[1].clone();
    let fix = re
        .captures(command.output.as_ref().unwrap())
        .unwrap()
        .get(1)
        .map_or("", |m| m.as_str());
    vec![command.script.replace(&broken, fix)]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "cargo_no_command".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const NO_SUCH_SUBCOMMAND_OLD: &str = "No such subcommand\n\n        Did you mean `build`?\n";
    const NO_SUCH_SUBCOMMAND: &str = "error: no such subcommand\n\n\tDid you mean `build`?\n";

    #[rstest]
    #[case("cargo buid", NO_SUCH_SUBCOMMAND_OLD, true)]
    #[case("cargo buils", NO_SUCH_SUBCOMMAND, true)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("cargo buid", NO_SUCH_SUBCOMMAND_OLD, vec!["cargo build"])]
    #[case("cargo buils", NO_SUCH_SUBCOMMAND, vec!["cargo build"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/cp_create_destination.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use std::path::Path;

pub fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains("No such file or directory")
            || (output.trim_end().ends_with("Not a directory"))
            || (output.starts_with("cp: directory")
                && output.trim_end().ends_with("does not exist"))
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["cp", "mv"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(dest_path_str) = command.script_parts.last() {
        let dir_to_create = if dest_path_str.ends_with('/') || dest_path_str.ends_with('\\') {
            // Case 1: Destination is a directory, like `bar/qux/`.
            Some(dest_path_str.trim_end_matches(['/', '\\']))
        } else {
            // Case 2: Destination is a file, like `bar/qux/file.txt`.
            Path::new(dest_path_str).parent().and_then(|p| p.to_str())
        };

        if let Some(dir_str) = dir_to_create {
            if !dir_str.is_empty() {
                return vec![system_shell
                    .unwrap()
                    .and(vec![&format!("mkdir -p {}", dir_str), &command.script])];
            }
        }
    }
    vec![]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "cp_create_destination".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("cp", "cp: directory foo does not exist\n", true)]
    #[case("mv", "No such file or directory", true)]
    #[case("cp", "", false)]
    #[case("mv", "", false)]
    #[case("ls", "No such file or directory", false)]
    fn test_match(#[case] script: &str, #[case] output: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(script.to_owned(), Some(output.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case(
        "cp foo bar/baz",
        "cp: bar/baz: No such file or directory",
        "mkdir -p bar && cp foo bar/baz"
    )]
    #[case(
        "mv foo bar/qux/",
        "mv: bar/qux/: No such file or directory",
        "mkdir -p bar/qux && mv foo bar/qux/"
    )]
    fn test_get_new_command(#[case] script: &str, #[case] output: &str, #[case] expected: &str) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(script.to_owned(), Some(output.to_owned()), None);
        assert_eq!(
            get_new_command(&mut command, Some(&system_shell)),
            vec![expected]
        );
    }
}

// FILE: ./src/rules/cd_cs.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use super::Rule;

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    command.script_parts[0] == "cs"
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec!["cd".to_owned() + &command.script[2..]]
}

/// Redirects cs to cd when there is a typo
/// Due to the proximity of the keys - d and s - this seems like a common typo
///
/// $ cs /etc/
/// cs: command not found
/// $ crab
/// cd /etc/ [enter/↑/↓/ctrl+c]
pub fn get_rule() -> Rule {
    Rule::new(
        "cd_cs".to_owned(),
        None,
        Some(900),
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;

    #[test]
    fn test_match_rule() {
        assert!(match_rule(
            &mut CrabCommand::new(
                "cs".to_owned(),
                Some("cs: command not found".to_owned()),
                None
            ),
            None
        ));
        assert!(match_rule(
            &mut CrabCommand::new(
                "cs /etc/".to_owned(),
                Some("cs: command not found".to_owned()),
                None
            ),
            None
        ));
    }

    #[test]
    fn test_get_new_command() {
        assert_eq!(
            get_new_command(
                &mut CrabCommand::new(
                    "cs /etc/".to_owned(),
                    Some("cs: command not found".to_owned()),
                    None
                ),
                None
            ),
            vec!["cd /etc/"]
        )
    }
}

// FILE: ./src/rules/ls_lah.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use super::{utils::match_rule_with_is_app, Rule};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    !command.script_parts.is_empty() && !command.script.contains("ls -l")
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["ls"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let mut script_parts = command.script_parts.clone();
    script_parts[0] = "ls -lah".to_string();
    vec![script_parts.join(" ")]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "ls_lah".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;

    use rstest::rstest;

    #[rstest]
    #[case("ls", "", true)]
    #[case("ls file.py", "", true)]
    #[case("ls /opt", "", true)]
    #[case("ls -lah /opt", "", false)]
    #[case("pacman -S binutils", "", false)]
    #[case("lsof", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("ls file.py", "", vec!["ls -lah file.py"])]
    #[case("ls", "", vec!["ls -lah"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/az_cli.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains("is not in the") && output.contains("command group")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["az"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let re_mistake = Regex::new(r"az(?:.*): '(.*)' is not in the '.*' command group.").unwrap();
    let re_options = Regex::new(r"(?m)^The most similar choice to '.*' is:\n\s*(.*)$").unwrap();
    let mistake = re_mistake
        .captures(command.output.as_ref().unwrap())
        .unwrap()
        .get(1)
        .map_or("", |m| m.as_str());
    let options = re_options
        .captures_iter(command.output.as_ref().unwrap())
        .map(|cap| cap[1].to_owned())
        .collect::<Vec<_>>();
    options
        .into_iter()
        .map(|o| command.script.replace(mistake, &o))
        .collect()
}

pub fn get_rule() -> Rule {
    Rule::new(
        "az_cli".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const NO_SUGGESTIONS: &str = r#"
az provider: error: the following arguments are required: _subcommand
usage: az provider [-h] {list,show,register,unregister,operation} ...
"#;

    const MISSPELLED_COMMAND: &str = r#"
az: 'providers' is not in the 'az' command group. See 'az --help'.

The most similar choice to 'providers' is:
    provider
"#;

    const MISSPELLED_SUBCOMMAND: &str = r#"
az provider: 'lis' is not in the 'az provider' command group. See 'az provider --help'.

The most similar choice to 'lis' is:
    list
"#;

    #[rstest]
    #[case("az providers", MISSPELLED_COMMAND, true)]
    #[case("az provider lis", MISSPELLED_SUBCOMMAND, true)]
    #[case("az provider", NO_SUGGESTIONS, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("az providers list", MISSPELLED_COMMAND, vec!["az provider list"])]
    #[case("az provider lis", MISSPELLED_SUBCOMMAND, vec!["az provider list"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_not_command.rs
use crate::{
    cli::command::CrabCommand,
    rules::utils::git::match_rule_with_git_support,
    shell::Shell,
    utils::{get_all_matched_commands, replace_command},
};

use super::{utils::git::get_new_command_with_git_support, Rule};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        stdout.contains(" is not a git command. See 'git --help'.")
            && (stdout.contains("The most similar command") || stdout.contains("Did you mean"))
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(stdout) = &command.output {
        let re = Regex::new(r"git: '([^']*)' is not a git command").unwrap();

        let broken_cmd = match re.captures(stdout) {
            Some(caps) => caps.get(1).map_or("", |m| m.as_str()),
            None => "",
        };
        let matched = get_all_matched_commands(
            stdout,
            Some(vec!["The most similar command", "Did you mean"]),
        );
        replace_command(
            command,
            broken_cmd,
            matched.iter().map(|s| s.as_str()).collect(),
        )
    } else {
        Vec::<String>::new()
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_not_command".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const GIT_NOT_COMMAND: &str = r#"git: 'brnch' is not a git command. See 'git --help'.

The most similar command is
branch
"#;
    const GIT_NOT_COMMAND_ONE_OF_THIS: &str = r#"git: 'st' is not a git command. See 'git --help'.

The most similar commands are
status
reset
stage
stash
stats
"#;
    const GIT_NOT_COMMAND_CLOSEST: &str = r#"
git: 'tags' is not a git command. See 'git --help'.

The most similar commands are
    stage
    tag
"#;
    const GIT_COMMAND: &str = "* master";

    #[rstest]
    #[case("git brnch", GIT_NOT_COMMAND.to_owned(), true)]
    #[case("git st", GIT_NOT_COMMAND_ONE_OF_THIS.to_owned(), true)]
    #[case("ls brnch", GIT_NOT_COMMAND.to_owned(), false)]
    #[case("git branch", GIT_COMMAND.to_owned(), false)]
    fn test_match(#[case] script: &str, #[case] output: String, #[case] is_match: bool) {
        let crab_command = &mut CrabCommand::new(script.to_owned(), Some(output), None);
        assert_eq!(match_rule(crab_command, None), is_match);
    }

    #[rstest]
    #[case("git brnch", GIT_NOT_COMMAND.to_owned(), vec!["git branch"])]
    #[case("git st", GIT_NOT_COMMAND_ONE_OF_THIS.to_owned(), vec!["git reset", "git stage", "git stash"])]
    #[case("git tags", GIT_NOT_COMMAND_CLOSEST.to_owned(), vec!["git stage", "git tag"])]
    fn test_get_new_command(
        #[case] script: &str,
        #[case] output: String,
        #[case] new_command: Vec<&str>,
    ) {
        let crab_command = &mut CrabCommand::new(script.to_owned(), Some(output), None);
        assert_eq!(get_new_command(crab_command, None), new_command);
    }
}

// FILE: ./src/rules/cd_mkdir.rs
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

use super::{
    get_new_command_without_sudo, match_rule_without_sudo, utils::match_rule_with_is_app, Rule,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        let stdout = stdout.to_lowercase();
        command.script.starts_with("cd ")
            && (stdout.contains("no such file or directory")
                || stdout.contains("cd: can't cd to")
                || stdout.contains("does not exist"))
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(
        |command| match_rule_with_is_app(auxiliary_match_rule, command, vec!["cd"], None),
        command,
    )
}

pub fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    let re = Regex::new(r"^cd (.*)").unwrap();
    let repl = |caps: &regex::Captures| format!("mkdir -p {} && cd {}", &caps[1], &caps[1]);
    vec![re.replace(&command.script, repl).to_string()]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "cd_mkdir".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("cd foo", "cd: foo: No such file or directory", true)]
    #[case("cd foo/bar/baz", "cd: foo: No such file or directory", true)]
    #[case("cd foo/bar/baz", "cd: can't cd to foo/bar/baz", true)]
    #[case("cd /foo/bar/", "cd: The directory \"/foo/bar/\" does not exist", true)]
    #[case("cd foo", "", false)]
    #[case("", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("cd foo", "", vec!["mkdir -p foo && cd foo"])]
    #[case("cd foo/bar/baz", "", vec!["mkdir -p foo/bar/baz && cd foo/bar/baz"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/python_command.rs
use super::{get_new_command_without_sudo, match_rule_without_sudo, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if !command.script_parts.is_empty() {
        if let Some(output) = &command.output {
            command.script_parts[0].ends_with(".py")
                && (output.contains("Permission denied") || output.contains("command not found"))
        } else {
            false
        }
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(auxiliary_match_rule, command)
}

pub fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    vec!["python ".to_owned() + &command.script]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "python_command".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("temp.py", "Permission denied", true)]
    #[case("temp.py", "[...] command not found [...]", true)]
    #[case("temp.rs", "[...] command not found [...]", false)]
    #[case("", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("./test_sudo.py", "", vec!["python ./test_sudo.py"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_diff_no_index.rs
use super::{utils::git::get_new_command_with_git_support, Rule};
use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
    utils::replace_argument,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if command.script_parts.len() > 2 {
        let files = command
            .script_parts
            .get(2..)
            .unwrap()
            .iter()
            .filter(|arg| !arg.starts_with('-'))
            .collect::<Vec<_>>();
        command.script.contains("diff")
            && !command.script.contains("--no-index")
            && files.len() == 2
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![replace_argument(&command.script, "diff", "diff --no-index")]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_diff_no_index".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("git diff foo bar", true)]
    #[case("git diff --no-index foo bar", false)]
    #[case("git diff foo", false)]
    #[case("git diff foo bar baz", false)]
    fn test_match(#[case] command: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some("".to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git diff foo bar", vec!["git diff --no-index foo bar"])]
    fn test_get_new_command(#[case] command: &str, #[case] expected: Vec<&str>) {
        let mut command = CrabCommand::new(command.to_owned(), Some("".to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_hook_bypass.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
    utils::replace_argument,
};

static HOOKED_COMMANDS: &[&str] = &["am", "commit", "push"];

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    HOOKED_COMMANDS
        .iter()
        .any(|&hooked_command| command.script_parts.contains(&hooked_command.to_owned()))
}

pub fn match_rule(command: &mut CrabCommand, _system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    match HOOKED_COMMANDS
        .iter()
        .find(|&cmd| command.script.contains(cmd))
    {
        Some(hooked_command) => vec![replace_argument(
            &command.script,
            hooked_command,
            &format!("{hooked_command} --no-verify"),
        )],
        None => vec![],
    }
}

pub fn get_new_command(
    command: &mut CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, _system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_hook_bypass".to_owned(),
        None,
        Some(1100),
        Some(false),
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("git am", "", true)]
    #[case("git commit", "", true)]
    #[case("git commit -m 'foo bar'", "", true)]
    #[case("git push", "", true)]
    #[case("git push -u foo bar", "", true)]
    #[case("git add foo", "", false)]
    #[case("git status", "", false)]
    #[case("git diff foo bar", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git am", "", vec!["git am --no-verify"])]
    #[case("git commit", "", vec!["git commit --no-verify"])]
    #[case("git commit -m 'foo bar'", "", vec!["git commit --no-verify -m 'foo bar'"])]
    #[case("git push", "", vec!["git push --no-verify"])]
    #[case("git push -p", "", vec!["git push --no-verify -p"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/git_branch_list.rs
use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
};

use super::{utils::git::get_new_command_with_git_support, Rule};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if command.script_parts.len() > 1 {
        command.script_parts[1..] == vec!["branch", "list"]
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![system_shell
        .unwrap()
        .and(vec!["git branch --delete list", "git branch"])]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_branch_list".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("git branch list", true)]
    #[case("", false)]
    #[case("git commit", false)]
    #[case("git branch", false)]
    #[case("git stash list", false)]
    fn test_match(#[case] command: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some("".to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git branch list", vec!["git branch --delete list && git branch"])]
    fn test_get_new_command(#[case] command: &str, #[case] expected: Vec<&str>) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some("".to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/brew_update_formula.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use super::Rule;

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(stdout) = &command.output {
        stdout.contains("Error: This command updates brew itself")
            && stdout.contains("Use `brew upgrade")
            && command.script.contains("update")
    } else {
        false
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command.script.replace("update", "upgrade")]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "brew_update_formula".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;

    const OUTPUT: &str = "Error: This command updates brew itself, and does not take formula names.\nUse `brew upgrade thefuck`.";

    macro_rules! parameterized_match_rule_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert!(match_rule(&mut command, None));
                }
            )*
        }
    }

    macro_rules! parameterized_unmatch_rule_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert!(!match_rule(&mut command, None));
                }
            )*
        }
    }

    macro_rules! parameterized_get_new_command_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, formula) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(OUTPUT.to_owned()),
                                None
                            );
                    assert_eq!(get_new_command(&mut command, None)[0], format!("brew upgrade {}", formula));
                }
            )*
        }
    }

    parameterized_match_rule_tests! {
        match_rule_1: ("brew update thefuck", OUTPUT),
    }

    parameterized_unmatch_rule_tests! {
        unmatch_rule_1: ("brew upgrade foo", ""),
        unmatch_rule_2: ("brew update", ""),
    }

    parameterized_get_new_command_tests! {
        get_new_command_1: ("brew update foo", "foo"),
        get_new_command_2: ("brew update bar zap", "bar zap"),
    }
}

// FILE: ./src/rules/unsudo.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell};

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(output) = &command.output {
        command.script_parts.first().is_some_and(|s| s == "sudo")
            && output
                .to_lowercase()
                .contains("you cannot perform this operation as root")
    } else {
        false
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command.script_parts[1..].join(" ")]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "unsudo".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("sudo ls", "you cannot perform this operation as root", true)]
    #[case("", "", false)]
    #[case("sudo ls", "Permission denied", false)]
    #[case("ls", "you cannot perform this operation as root", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("sudo ls", "", vec!["ls"])]
    #[case("sudo pacaur -S helloworld", "", vec!["pacaur -S helloworld"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/aws_cli.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains("usage:") && output.contains("maybe you meant:")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["aws"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(output) = &command.output {
        let re_invalid_choice = Regex::new(r"Invalid choice: '(.*)', maybe you meant:").unwrap();
        let re_options = Regex::new(r"(?m)^\s*\*\s(.*)").unwrap();
        let mistake = re_invalid_choice
            .captures(output)
            .unwrap()
            .get(1)
            .map_or("", |m| m.as_str());
        let options = re_options
            .captures_iter(output)
            .map(|cap| cap[1].to_string())
            .collect::<Vec<_>>();
        options
            .iter()
            .map(|o| command.script.replace(mistake, o))
            .collect()
    } else {
        Vec::<String>::new()
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "aws_cli".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const NO_SUGGESTIONS: &str = r#"
usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
To see help text, you can run:

  aws help
  aws <command> help
  aws <command> <subcommand> help
aws: error: argument command: Invalid choice, valid choices are:

dynamodb                                 | dynamodbstreams
ec2                                      | ecr
"#;

    const MISSPELLED_COMMAND: &str = r#"
usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
To see help text, you can run:

  aws help
  aws <command> help
  aws <command> <subcommand> help
aws: error: argument command: Invalid choice, valid choices are:

dynamodb                                 | dynamodbstreams
ec2                                      | ecr


Invalid choice: 'dynamdb', maybe you meant:

  * dynamodb
"#;

    const MISSPELLED_SUBCOMMAND: &str = r#"
usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
To see help text, you can run:

  aws help
  aws <command> help
  aws <command> <subcommand> help
aws: error: argument operation: Invalid choice, valid choices are:

query                                    | scan
update-item                              | update-table


Invalid choice: 'scn', maybe you meant:

  * scan
"#;

    const MISSPELLED_SUBCOMMAND_WITH_MULTIPLE_OPTIONS: &str = r#"
usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
To see help text, you can run:

  aws help
  aws <command> help
  aws <command> <subcommand> help
aws: error: argument operation: Invalid choice, valid choices are:

describe-table                           | get-item
list-tables                              | put-item


Invalid choice: 't-item', maybe you meant:

  * put-item
  * get-item
"#;

    #[rstest]
    #[case("aws dynamdb scan", MISSPELLED_COMMAND, true)]
    #[case("aws dynamodb scn", MISSPELLED_SUBCOMMAND, true)]
    #[case(
        "aws dynamodb t-item",
        MISSPELLED_SUBCOMMAND_WITH_MULTIPLE_OPTIONS,
        true
    )]
    #[case("aws dynamodb invalid", NO_SUGGESTIONS, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("aws dynamdb scan", MISSPELLED_COMMAND, vec!["aws dynamodb scan"])]
    #[case("aws dynamodb scn", MISSPELLED_SUBCOMMAND, vec!["aws dynamodb scan"])]
    #[case("aws dynamodb t-item", MISSPELLED_SUBCOMMAND_WITH_MULTIPLE_OPTIONS, vec!["aws dynamodb put-item", "aws dynamodb get-item"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/grep_recursive.rs
use super::{get_new_command_without_sudo, match_rule_without_sudo, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.to_lowercase().contains("is a directory")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(auxiliary_match_rule, command)
}

pub fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    vec!["grep -r ".to_owned() + &command.script[5..]]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "grep_recursive".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("grep blah .", "grep: .: Is a directory", true)]
    #[case("grep café .", "grep: .: Is a directory", true)]
    #[case("", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("grep blah .", "", vec!["grep -r blah ."])]
    #[case("grep café .", "", vec!["grep -r café ."])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/prove_recursively.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use std::path::Path;

fn is_recursive(part: &str) -> bool {
    part == "--recurse" || (!part.starts_with("--") && part.starts_with('-') && part.contains('r'))
}

fn is_dir(part: &str) -> bool {
    !part.starts_with('-') && Path::new(part).exists()
}

fn auxiliary_match_rule<F>(command: &CrabCommand, fn_is_dir: F) -> bool
where
    F: Fn(&str) -> bool,
{
    if let Some(output) = &command.output {
        output.contains("NOTESTS")
            && !command.script_parts[1..]
                .iter()
                .any(|part| is_recursive(part))
            && command.script_parts[1..].iter().any(|part| fn_is_dir(part))
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(
        |command| auxiliary_match_rule(command, is_dir),
        command,
        vec!["prove"],
        None,
    )
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let mut parts = command.script_parts.clone();
    parts.insert(1, "-r".to_owned());
    vec![parts.join(" ")]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "prove_recursively".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{auxiliary_match_rule, get_new_command};
    use crate::cli::command::CrabCommand;
    use crate::rules::utils::match_rule_with_is_app;
    use crate::shell::Bash;
    use rstest::rstest;

    const OUTPUT: &str =
        "Files=0, Tests=0,  0 wallclock secs ( 0.00 usr +  0.00 sys =  0.00 CPU)\nResult: NOTESTS";

    #[rstest]
    #[case("prove -lv t", OUTPUT, true, true)]
    #[case("prove app/t", OUTPUT, true, true)]
    #[case("prove -lv t", OUTPUT, false, false)]
    #[case("prove -r t", OUTPUT, true, false)]
    #[case("prove --recurse t", OUTPUT, true, false)]
    fn test_match(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] is_dir: bool,
        #[case] is_match: bool,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(
            match_rule_with_is_app(
                |command| auxiliary_match_rule(command, |s| is_dir),
                &command,
                vec!["prove"],
                None,
            ),
            is_match
        );
    }

    #[rstest]
    #[case("prove -lv t", OUTPUT, vec!["prove -r -lv t"])]
    #[case("prove t", OUTPUT, vec!["prove -r t"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/sudo_command_from_user_path.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::utils::replace_argument;
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;
use which::which;

fn is_terminal_command(terminal_command: &str) -> bool {
    which(terminal_command).is_ok()
}

fn get_command_name(command_output: &str) -> Option<String> {
    let re = Regex::new(r"sudo: (.*): command not found").unwrap();
    re.captures(command_output).map(|caps| caps[1].to_owned())
}

fn auxiliary_match_rule<F>(command: &CrabCommand, fn_is_terminal_command: F) -> bool
where
    F: Fn(&str) -> bool,
{
    if let Some(output) = &command.output {
        if output.contains("command not found") {
            if let Some(command_name) = get_command_name(output) {
                fn_is_terminal_command(&command_name)
            } else {
                false
            }
        } else {
            false
        }
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(
        |command| auxiliary_match_rule(command, is_terminal_command),
        command,
        vec!["sudo"],
        None,
    )
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(output) = &command.output {
        let command_name = get_command_name(output);
        if let Some(command_name) = command_name {
            vec![replace_argument(
                &command.script,
                &command_name,
                &format!("env \"PATH=$PATH\" {command_name}"),
            )]
        } else {
            vec![]
        }
    } else {
        vec![]
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "sudo_command_from_user_path".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{auxiliary_match_rule, get_new_command};
    use crate::cli::command::CrabCommand;
    use crate::rules::utils::match_rule_with_is_app;
    use crate::shell::Bash;
    use rstest::rstest;

    fn error_command_not_found(command: &str) -> String {
        format!("sudo: {command}: command not found")
    }

    #[rstest]
    #[case("sudo npm install -g react-native-cli", &error_command_not_found("npm"), true, true)]
    #[case("sudo -u app appcfg update .", &error_command_not_found("appcfg"), true, true)]
    #[case("npm --version", &error_command_not_found("npm"), true, false)]
    #[case("sudo npm --version", "", true, false)]
    #[case("sudo npm --version", &error_command_not_found("npm"), false, false)]
    fn test_match(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] is_terminal_command: bool,
        #[case] is_match: bool,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(
            match_rule_with_is_app(
                |command| auxiliary_match_rule(command, |s| is_terminal_command),
                &command,
                vec!["sudo"],
                None,
            ),
            is_match
        );
    }

    #[rstest]
    #[case("sudo npm install -g react-native-cli", &error_command_not_found("npm"), vec!["sudo env \"PATH=$PATH\" npm install -g react-native-cli"])]
    #[case("sudo -u app appcfg update .", &error_command_not_found("appcfg"), vec!["sudo -u app env \"PATH=$PATH\" appcfg update ."])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_pull_uncommitted_changes.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("pull")
            && (stdout.contains("You have unstaged changes")
                || stdout.contains("contains uncommitted changes"))
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, _system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![system_shell
        .unwrap()
        .and(vec!["git stash", "git pull", "git stash pop"])]
}

pub fn get_new_command(
    command: &mut CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, _system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_pull_uncommitted_changes".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;
    const OUTPUT: &str = "error: Cannot pull with rebase: You have unstaged changes.";

    #[rstest]
    #[case("git pull", OUTPUT, true)]
    #[case("git pull", "", false)]
    #[case("ls", OUTPUT, false)]
    fn test_match(#[case] command: &str, #[case] output: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(output.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git pull", "error: Cannot pull with rebase: You have unstaged changes.", vec!["git stash && git pull && git stash pop"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] output: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(output.to_owned()), None);
        assert_eq!(
            get_new_command(&mut command, Some(&system_shell)),
            expected.iter().map(|&s| s.to_owned()).collect::<Vec<_>>()
        );
    }
}

// FILE: ./src/rules/git_branch_delete.rs
use crate::utils::replace_argument;
use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
};

use super::{utils::git::get_new_command_with_git_support, Rule};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("branch -d")
            && stdout.contains("If you are sure you want to delete it")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![replace_argument(&command.script, "-d", "-D")]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_branch_delete".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const OUTPUT: &str = r#"error: The branch 'branch' is not fully merged.
If you are sure you want to delete it, run 'git branch -D branch'.
"#;

    #[rstest]
    #[case("git branch -d branch", OUTPUT, true)]
    #[case("git branch -d branch", "", false)]
    #[case("ls", OUTPUT, false)]
    fn test_match(#[case] command: &str, #[case] output: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(output.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git branch -d branch", OUTPUT, vec!["git branch -D branch"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] output: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(output.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/history.rs
use super::Rule;
use crate::cli::command::CrabCommand;
use crate::shell::Shell;
use crate::utils::{get_close_matches, get_valid_history_without_current};

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    !get_close_matches(
        &command.script,
        get_valid_history_without_current(command, system_shell.unwrap())
            .iter()
            .map(|s| s.as_str())
            .collect::<Vec<&str>>()
            .as_slice(),
        None,
        None,
    )
    .is_empty()
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_close_matches(
        &command.script,
        get_valid_history_without_current(command, system_shell.unwrap())
            .iter()
            .map(|s| s.as_str())
            .collect::<Vec<&str>>()
            .as_slice(),
        None,
        None,
    )
    .iter()
    .map(|&s| s.to_string())
    .collect()
}

pub fn get_rule() -> Rule {
    Rule::new(
        "history".to_owned(),
        None,
        Some(9999),
        None,
        match_rule,
        get_new_command,
        None,
    )
}

// priority = 9999

// FILE: ./src/rules/git_diff_staged.rs
use super::{utils::git::get_new_command_with_git_support, Rule};

use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
    utils::replace_argument,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    command.script.contains("diff") && !command.script.contains("--staged")
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![replace_argument(&command.script, "diff", "diff --staged")]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_diff_staged".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;

    use rstest::rstest;
    #[rstest]
    #[case("git diff foo", "", true)]
    #[case("git diff", "", true)]
    #[case("git diff --staged", "", false)]
    #[case("git tag", "", false)]
    #[case("git branch", "", false)]
    #[case("git log", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git diff", "", "git diff --staged")]
    #[case("git diff foo", "", "git diff --staged foo")]
    fn test_get_new_command(#[case] command: &str, #[case] stdout: &str, #[case] expected: &str) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), vec![expected]);
    }
}

// FILE: ./src/rules/django_south_ghost.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell};

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    command.script.contains("manage.py")
        && command.script.contains("migrate")
        && command
            .output
            .as_ref()
            .is_some_and(|output| output.contains("or pass --delete-ghost-migrations"))
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![format!("{} --delete-ghost-migrations", command.script)]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "django_south_ghost".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const OUTPUT: &str = r#"Traceback (most recent call last):
  File "/home/nvbn/work/.../bin/python", line 42, in <module>
    exec(compile(__file__f.read(), __file__, "exec"))
  File "/home/nvbn/work/.../app/manage.py", line 34, in <module>
    execute_from_command_line(sys.argv)
  File "/home/nvbn/work/.../lib/django/core/management/__init__.py", line 443, in execute_from_command_line
    utility.execute()
  File "/home/nvbn/work/.../lib/django/core/management/__init__.py", line 382, in execute
    self.fetch_command(subcommand).run_from_argv(self.argv)
  File "/home/nvbn/work/.../lib/django/core/management/base.py", line 196, in run_from_argv
    self.execute(*args, **options.__dict__)
  File "/home/nvbn/work/.../lib/django/core/management/base.py", line 232, in execute
    output = self.handle(*args, **options)
  File "/home/nvbn/work/.../app/lib/south/management/commands/migrate.py", line 108, in handle
    ignore_ghosts = ignore_ghosts,
  File "/home/nvbn/work/.../app/lib/south/migration/__init__.py", line 193, in migrate_app
    applied_all = check_migration_histories(applied_all, delete_ghosts, ignore_ghosts)
  File "/home/nvbn/work/.../app/lib/south/migration/__init__.py", line 88, in check_migration_histories
    raise exceptions.GhostMigrations(ghosts)
south.exceptions.GhostMigrations:

 ! These migrations are in the database but not on disk:
    <app1: 0033_auto__...>
    <app1: 0034_fill_...>
    <app1: 0035_rename_...>
    <app2: 0003_add_...>
    <app2: 0004_denormalize_...>
    <app1: 0033_auto....>
    <app1: 0034_fill...>
 ! I'm not trusting myself; either fix this yourself by fiddling
 ! with the south_migrationhistory table, or pass --delete-ghost-migrations
 ! to South to have it delete ALL of these records (this may not be good).
"#;
    #[rstest]
    #[case("./manage.py migrate", OUTPUT, true)]
    #[case("python manage.py migrate", OUTPUT, true)]
    #[case("./manage.py migrate", "", false)]
    #[case("app migrate", OUTPUT, false)]
    #[case("./manage.py test", OUTPUT, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("./manage.py migrate auth", "", vec!["./manage.py migrate auth --delete-ghost-migrations"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_branch_exists.rs
use super::{utils::git::get_new_command_with_git_support, Rule};
use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        stdout.contains("fatal: A branch named '") && stdout.contains("' already exists.")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(stdout) = &command.output {
        let re_branch_name = Regex::new(r"fatal: A branch named '(.+)' already exists.").unwrap();
        if let Some(captures) = re_branch_name.captures(stdout) {
            let mut new_commands = Vec::<String>::new();
            let branch_name = &captures[1].replace('\'', r"\'");
            let new_command_templates = vec![
                vec!["git branch -d", "git branch"],
                vec!["git branch -d", "git checkout -b"],
                vec!["git branch -D", "git branch"],
                vec!["git branch -D", "git checkout -b"],
                vec!["git checkout"],
            ];
            for new_command_template in new_command_templates {
                let new_command_with_branch = new_command_template
                    .iter()
                    .map(|s| format!("{s} {branch_name}"))
                    .collect::<Vec<String>>();
                new_commands.push(
                    system_shell
                        .unwrap()
                        .and(new_command_with_branch.iter().map(AsRef::as_ref).collect()),
                );
            }
            new_commands
        } else {
            Vec::<String>::new()
        }
    } else {
        Vec::<String>::new()
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_branch_exists".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;

    const OUTPUT: &str = "fatal: A branch named '#' already exists.";

    use rstest::rstest;

    #[rstest]
    #[case("git branch foo", "foo", OUTPUT)]
    #[case("git checkout bar", "bar", OUTPUT)]
    #[case("git checkout -b \"let's-push-this\"", "\"let's-push-this\"", OUTPUT)]
    fn test_match(
        #[case] command: &str,
        #[case] src_branch_name: &str,
        #[case] stdout_template: &str,
    ) {
        let stdout = stdout_template.replace('#', src_branch_name);
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout), None);
        assert!(match_rule(&mut command, None));
    }

    #[rstest]
    #[case("git branch foo")]
    #[case("git checkout bar")]
    #[case("git checkout -b \"let's-push-this\"")]
    fn test_not_match(#[case] command: &str) {
        let mut command = CrabCommand::new(command.to_owned(), Some("".to_owned()), None);
        assert!(!match_rule(&mut command, None));
    }

    #[rstest]
    #[case("git branch foo", "foo", "foo", OUTPUT)]
    #[case("git checkout bar", "bar", "bar", OUTPUT)]
    #[case(
        "git checkout -b \"let's-push-this\"",
        "let's-push-this",
        "let\\'s-push-this",
        OUTPUT
    )]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] src_branch_name: &str,
        #[case] branch_name: &str,
        #[case] stdout_template: &str,
    ) {
        let expected: Vec<String> = [
            "git branch -d # && git branch #",
            "git branch -d # && git checkout -b #",
            "git branch -D # && git branch #",
            "git branch -D # && git checkout -b #",
            "git checkout #",
        ]
        .iter()
        .map(|s| s.replace('#', branch_name))
        .collect();
        let stdout = stdout_template.replace('#', src_branch_name);
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/mod.rs
use crate::shell::Shell;
use core::fmt;
use crate::cli::{command::CorrectedCommand, command::CrabCommand};

// Publicly re-export the utils module so other rules can use it
pub mod utils;

// The Rule struct needs to be defined *before* we include the generated
// code that uses it.
pub struct Rule {
    name: String,
    enabled_by_default: bool,
    priority: u16,
    requires_output: bool,
    pub match_rule: fn(&mut CrabCommand, Option<&dyn Shell>) -> bool,
    get_new_command: fn(&mut CrabCommand, Option<&dyn Shell>) -> Vec<String>,
    side_effect: Option<fn(CrabCommand, Option<&str>)>,
}

impl fmt::Display for Rule {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.name)
    }
}

impl Rule {
    pub fn new(
        name: String,
        enabled_by_default: Option<bool>,
        priority: Option<u16>,
        requires_output: Option<bool>,
        match_rule: fn(&mut CrabCommand, Option<&dyn Shell>) -> bool,
        get_new_command: fn(&mut CrabCommand, Option<&dyn Shell>) -> Vec<String>,
        side_effect: Option<fn(CrabCommand, Option<&str>)>,
    ) -> Self {
        Self {
            name,
            enabled_by_default: enabled_by_default.unwrap_or(true),
            priority: priority.unwrap_or(1000),
            requires_output: requires_output.unwrap_or(true),
            match_rule,
            get_new_command,
            side_effect,
        }
    }

    fn get_corrected_commands(
        &self,
        command: &mut CrabCommand,
        system_shell: &dyn Shell,
    ) -> Vec<CorrectedCommand> {
        let mut new_commands: Vec<CorrectedCommand> = vec![];
        for (n, new_command) in (self.get_new_command)(command, Some(system_shell))
            .iter()
            .enumerate()
        {
            new_commands.push(CorrectedCommand::new(
                new_command.to_owned(),
                self.side_effect,
                (n as u16 + 1) * self.priority,
            ));
        }
        new_commands
    }
}

// This single line will bring in all `mod` declarations and the `get_rules()` function.
// The compiler will correctly resolve `mod cp_create_destination;` to the file
// `src/rules/cp_create_destination.rs`.
include!(concat!(env!("OUT_DIR"), "/rules.rs"));

// The rest of the functions remain here.
pub fn get_corrected_commands(
    command: &mut CrabCommand,
    system_shell: &dyn Shell,
) -> Vec<CorrectedCommand> {
    let mut corrected_commands: Vec<CorrectedCommand> = vec![];
    for rule in get_rules() {
        if (rule.match_rule)(command, Some(system_shell)) {
            for corrected in rule.get_corrected_commands(command, system_shell) {
                corrected_commands.push(corrected);
            }
        }
    }
    organize_commands(corrected_commands)
}

pub fn organize_commands(mut corrected_commands: Vec<CorrectedCommand>) -> Vec<CorrectedCommand> {
    corrected_commands.sort_by(|a, b| a.priority.cmp(&b.priority));
    corrected_commands.dedup_by(|a, b| a.script.eq(&b.script));
    corrected_commands
}

pub fn match_rule_without_sudo<F>(match_function: F, command: &mut CrabCommand) -> bool
where
    F: Fn(&CrabCommand) -> bool,
{
    if !command.script.starts_with("sudo ") {
        match_function(command)
    } else {
        let new_script = command.script[5..].to_owned();
        match_function(&command.update(Some(new_script), None, None))
    }
}

pub fn get_new_command_without_sudo(
    get_new_command_function: fn(&CrabCommand) -> Vec<String>,
    command: &mut CrabCommand,
) -> Vec<String> {
    if !command.script.starts_with("sudo ") {
        get_new_command_function(command)
    } else {
        let new_script = command.script[5..].to_owned();
        command.script = new_script;
        get_new_command_function(command)
            .iter()
            .map(|cmd| "sudo ".to_owned() + cmd)
            .collect()
    }
}

// FILE: ./src/rules/brew_uninstall.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        (command
            .script_parts
            .get(1)
            .is_some_and(|s| s == "uninstall" || s == "rm" || s == "remove"))
            && output.contains("brew uninstall --force")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["brew"], Some(2))
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let mut command_parts = command.script_parts.clone();
    "uninstall".clone_into(&mut command_parts[1]);
    command_parts.insert(2, "--force".to_owned());
    vec![command_parts.join(" ")]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "brew_uninstall".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}
#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const OUTPUT: &str = "Uninstalling /usr/local/Cellar/tbb/4.4-20160916... (118 files, 1.9M)\ntbb 4.4-20160526, 4.4-20160722 are still installed.\nRemove all versions with `brew uninstall --force tbb`.\n";

    #[rstest]
    #[case("brew uninstall tbb", OUTPUT, true)]
    #[case("brew rm tbb", OUTPUT, true)]
    #[case("brew remove tbb", OUTPUT, true)]
    #[case(
        "brew remove gnuplot",
        "Uninstalling /usr/local/Cellar/gnuplot/5.0.4_1... (44 files, 2.3M)\n",
        false
    )]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("brew uninstall tbb", OUTPUT, vec!["brew uninstall --force tbb"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_remote_delete.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    command.script.contains("remote delete")
}

pub fn match_rule(command: &mut CrabCommand, _system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    let re = Regex::new(r"delete").unwrap();
    vec![re.replace(&command.script, "remove").to_string()]
}

pub fn get_new_command(
    command: &mut CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, _system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_remote_delete".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("git remote delete foo", "", true)]
    #[case("git remote remove foo", "", false)]
    #[case("git remote add foo", "", false)]
    #[case("git commit", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git remote delete foo", "", vec!["git remote remove foo"])]
    #[case("git remote delete delete", "", vec!["git remote remove delete"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/cpp11.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains(
            "This file requires compiler and library support for the ISO C++ 2011 standard.",
        ) || output.contains("-Wc++11-extensions")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["g++", "clang++"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command.script.clone() + " -std=c++11"]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "cpp11".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("g++ foo.cpp", "foo.cpp:1:1: error: This file requires compiler and library support for the ISO C++ 2011 standard. This support must be enabled with the -std=c++11 or -std=gnu++11 compiler options.", true)]
    #[case("clang++ bar.cpp", "bar.cpp:1:1: warning: using extended identifiers requires -std=c++11 or -std=gnu++11 [-Wc++11-extensions]", true)]
    #[case(
        "g++ baz.cpp",
        "baz.cpp:1:1: error: 'auto' type specifier is a C++11 extension",
        false
    )]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("g++ foo.cpp", "foo.cpp:1:1: error: This file requires compiler and library support for the ISO C++ 2011 standard. This support must be enabled with the -std=c++11 or -std=gnu++11 compiler options.", vec!["g++ foo.cpp -std=c++11"])]
    #[case("clang++ bar.cpp", "bar.cpp:1:1: warning: using extended identifiers requires -std=c++11 or -std=gnu++11 [-Wc++11-extensions]", vec!["clang++ bar.cpp -std=c++11"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/pip_unknown_command.rs
use super::{match_rule_without_sudo, utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell, utils::replace_argument};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command.script.contains("pip")
            && output.contains("unknown command")
            && output.contains("maybe you meant")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(
        |command| {
            match_rule_with_is_app(
                auxiliary_match_rule,
                command,
                vec!["pip", "pip2", "pip3"],
                None,
            )
        },
        command,
    )
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(output) = &command.output {
        println!("{output:?}");
        let broken_cmd = Regex::new(r#"ERROR: unknown command "([^"]+)""#)
            .unwrap()
            .captures(output)
            .and_then(|caps| caps.get(1).map(|m| m.as_str().to_owned()))
            .unwrap_or_default();
        let new_cmd = Regex::new(r#"maybe you meant "([^"]+)""#)
            .unwrap()
            .captures(output)
            .and_then(|caps| caps.get(1).map(|m| m.as_str().to_owned()))
            .unwrap_or_default();
        vec![replace_argument(&command.script, &broken_cmd, &new_cmd)]
    } else {
        vec![]
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "pip_unknown_command".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    fn pip_unknown_cmd(broken: &str, suggested: &str) -> String {
        format!(r#"ERROR: unknown command "{broken}" - maybe you meant "{suggested}""#)
    }

    #[rstest]
    #[case("pip instatl", &pip_unknown_cmd("instatl", "install"), true)]
    #[case("pip i", r#"ERROR: unknown command "i""#, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("pip un+install thefuck", &pip_unknown_cmd("un+install", "uninstall"), vec!["pip uninstall thefuck"])]
    #[case("pip instatl", &pip_unknown_cmd("instatl", "install"), vec!["pip install"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/apt_list_upgradable.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use super::{
    get_new_command_without_sudo, match_rule_without_sudo, utils::match_rule_with_is_app, Rule,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        stdout.contains("apt list --upgradable")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(
        |command| match_rule_with_is_app(auxiliary_match_rule, command, vec!["apt"], None),
        command,
    )
}

fn _get_new_command(command: &CrabCommand) -> Vec<String> {
    vec!["apt list --upgradable".to_owned()]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "apt_list_upgradable".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const FULL_ENGLISH_OUTPUT: &str = r#"
Hit:1 http://us.archive.ubuntu.com/ubuntu zesty InRelease
Hit:2 http://us.archive.ubuntu.com/ubuntu zesty-updates InRelease
Get:3 http://us.archive.ubuntu.com/ubuntu zesty-backports InRelease [89.2 kB]
Hit:4 http://security.ubuntu.com/ubuntu zesty-security InRelease
Hit:5 http://ppa.launchpad.net/ubuntu-mozilla-daily/ppa/ubuntu zesty InRelease
Hit:6 https://download.docker.com/linux/ubuntu zesty InRelease
Hit:7 https://cli-assets.heroku.com/branches/stable/apt ./ InRelease
Fetched 89.2 kB in 0s (122 kB/s)
Reading package lists... Done
Building dependency tree
Reading state information... Done
8 packages can be upgraded. Run 'apt list --upgradable' to see them.
"#;

    const NO_MATCH_OUTPUT: &str = r#"
Hit:1 http://us.archive.ubuntu.com/ubuntu zesty InRelease
Get:2 http://us.archive.ubuntu.com/ubuntu zesty-updates InRelease [89.2 kB]
Get:3 http://us.archive.ubuntu.com/ubuntu zesty-backports InRelease [89.2 kB]
Get:4 http://security.ubuntu.com/ubuntu zesty-security InRelease [89.2 kB]
Hit:5 https://cli-assets.heroku.com/branches/stable/apt ./ InRelease
Hit:6 http://ppa.launchpad.net/ubuntu-mozilla-daily/ppa/ubuntu zesty InRelease
Hit:7 https://download.docker.com/linux/ubuntu zesty InRelease
Get:8 http://us.archive.ubuntu.com/ubuntu zesty-updates/main i386 Packages [232 kB]
Get:9 http://us.archive.ubuntu.com/ubuntu zesty-updates/main amd64 Packages [235 kB]
Get:10 http://us.archive.ubuntu.com/ubuntu zesty-updates/main amd64 DEP-11 Metadata [55.2 kB]
Get:11 http://us.archive.ubuntu.com/ubuntu zesty-updates/main DEP-11 64x64 Icons [32.3 kB]
Get:12 http://us.archive.ubuntu.com/ubuntu zesty-updates/universe amd64 Packages [156 kB]
Get:13 http://us.archive.ubuntu.com/ubuntu zesty-updates/universe i386 Packages [156 kB]
Get:14 http://us.archive.ubuntu.com/ubuntu zesty-updates/universe amd64 DEP-11 Metadata [175 kB]
Get:15 http://us.archive.ubuntu.com/ubuntu zesty-updates/universe DEP-11 64x64 Icons [253 kB]
Get:16 http://us.archive.ubuntu.com/ubuntu zesty-updates/multiverse amd64 DEP-11 Metadata [5,840 B]
Get:17 http://us.archive.ubuntu.com/ubuntu zesty-backports/universe amd64 DEP-11 Metadata [4,588 B]
Get:18 http://security.ubuntu.com/ubuntu zesty-security/main amd64 DEP-11 Metadata [12.7 kB]
Get:19 http://security.ubuntu.com/ubuntu zesty-security/main DEP-11 64x64 Icons [17.6 kB]
Get:20 http://security.ubuntu.com/ubuntu zesty-security/universe amd64 DEP-11 Metadata [21.6 kB]
Get:21 http://security.ubuntu.com/ubuntu zesty-security/universe DEP-11 64x64 Icons [47.7 kB]
Get:22 http://security.ubuntu.com/ubuntu zesty-security/multiverse amd64 DEP-11 Metadata [208 B]
Fetched 1,673 kB in 0s (1,716 kB/s)
Reading package lists... Done
Building dependency tree
Reading state information... Done
All packages are up to date.
"#;
    const GERMAN_OUTPUT: &str = "Führen Sie »apt list --upgradable« aus, um sie anzuzeigen.";

    #[rstest]
    #[case("sudo apt update", FULL_ENGLISH_OUTPUT, true)]
    #[case("sudo apt update", GERMAN_OUTPUT, true)]
    #[case("sudo apt update", NO_MATCH_OUTPUT, false)]
    #[case("apt-cache search foo", "", false)]
    #[case("aptitude search foo", "", false)]
    #[case("apt search foo", "", false)]
    #[case("apt-get install foo", "", false)]
    #[case("apt-get source foo", "", false)]
    #[case("apt-get clean", "", false)]
    #[case("apt-get remove", "", false)]
    #[case("apt-get update", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("sudo apt update", FULL_ENGLISH_OUTPUT, vec!["sudo apt list --upgradable"])]
    #[case("sudo apt update", GERMAN_OUTPUT, vec!["sudo apt list --upgradable"])]
    #[case("apt update", FULL_ENGLISH_OUTPUT, vec!["apt list --upgradable"])]
    #[case("apt update", GERMAN_OUTPUT, vec!["apt list --upgradable"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_commit_add.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
    utils::replace_argument,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        stdout.contains("no changes added to commit")
            && command.script_parts.contains(&"commit".to_owned())
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    let opts = vec!["-a", "-p"];
    let mut new_commands = Vec::new();

    for opt in opts {
        let new_command = replace_argument(&command.script, "commit", &format!("commit {opt}"));
        new_commands.push(new_command);
    }
    new_commands
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_commit_add".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("git commit -m \"test\"", "no changes added to commit")]
    #[case("git commit", "no changes added to commit")]
    fn test_match(#[case] script: &str, #[case] output: String) {
        let crab_command = &mut CrabCommand::new(script.to_owned(), Some(output), None);
        assert!(match_rule(crab_command, None));
    }

    #[rstest]
    #[case(
        "git commit -m \"test\"",
        " 1 file changed, 15 insertions(+), 14 deletions(-)"
    )]
    #[case("git branch foo", "")]
    #[case("git checkout feature/test_commit", "")]
    #[case("git push", "")]
    fn test_not_match(#[case] script: &str, #[case] output: String) {
        let crab_command = &mut CrabCommand::new(script.to_owned(), Some(output), None);
        assert!(!match_rule(crab_command, None));
    }

    #[rstest]
    #[case("git commit", vec!["git commit -a", "git commit -p"])]
    #[case("git commit -m \"foo\"", vec!["git commit -a -m \"foo\"", "git commit -p -m \"foo\""])]
    fn test_get_new_command(#[case] script: &str, #[case] new_command: Vec<&str>) {
        let crab_command = &mut CrabCommand::new(script.to_owned(), None, None);
        assert_eq!(get_new_command(crab_command, None), new_command);
    }
}

// FILE: ./src/rules/composer_not_command.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        let output_lower = output.to_lowercase();
        (output_lower.contains("did you mean this?")
            || output_lower.contains("did you mean one of these?"))
            || (command.script_parts.contains(&"install".to_owned())
                && output_lower.contains("composer require"))
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["composer"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(output) = &command.output {
        let re_broken_cmd = Regex::new(r#"Command "([^']*)" is not defined"#).unwrap();
        let re_new_cmd = Regex::new(r"Did you mean this\?[^\n]*\n\s*([^\n]*)").unwrap();
        let re_new_cmd_alt = Regex::new(r"Did you mean one of these\?[^\n]*\n\s*([^\n]*)").unwrap();
        let broken_cmd;
        let mut new_cmd;
        if command.script_parts.contains(&"install".to_owned())
            && output.to_lowercase().contains("composer require")
        {
            broken_cmd = "install".to_owned();
            new_cmd = "require".to_owned();
        } else {
            if let Some(captures) = re_broken_cmd.captures(output) {
                broken_cmd = captures.get(1).map_or("", |m| m.as_str()).to_owned();
            } else {
                return Vec::<String>::new();
            }
            if let Some(captures) = re_new_cmd.captures(output) {
                new_cmd = captures.get(1).map_or("", |m| m.as_str()).to_owned();
            } else if let Some(captures) = re_new_cmd_alt.captures(output) {
                new_cmd = captures.get(1).map_or("", |m| m.as_str()).to_owned();
            } else {
                return Vec::<String>::new();
            }
        }
        vec![command.script.replace(&broken_cmd, new_cmd.trim())]
    } else {
        Vec::<String>::new()
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "composer_not_command".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}
#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const COMPOSER_NOT_COMMAND: &str = "\n\n                                    \n  [InvalidArgumentException]        \n  Command \"udpate\" is not defined.  \n  Did you mean this?                \n      update                        \n                                    \n\n\n";
    const COMPOSER_NOT_COMMAND_ONE_OF_THIS: &str = "\n\n                                   \n  [InvalidArgumentException]       \n  Command \"pdate\" is not defined.  \n  Did you mean one of these?       \n      selfupdate                   \n      self-update                  \n      update                       \n                                   \n\n\n";
    const COMPOSER_REQUIRE_INSTEAD_OF_INSTALL: &str = "Invalid argument package. Use \"composer require package\" instead to add packages to your composer.json.";

    #[rstest]
    #[case("composer udpate", COMPOSER_NOT_COMMAND, true)]
    #[case("composer pdate", COMPOSER_NOT_COMMAND_ONE_OF_THIS, true)]
    #[case("composer install package", COMPOSER_REQUIRE_INSTEAD_OF_INSTALL, true)]
    #[case("ls update", COMPOSER_NOT_COMMAND, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("composer udpate", COMPOSER_NOT_COMMAND, vec!["composer update"])]
    #[case("composer pdate", COMPOSER_NOT_COMMAND_ONE_OF_THIS, vec!["composer selfupdate"])]
    #[case("composer install package", COMPOSER_REQUIRE_INSTEAD_OF_INSTALL, vec!["composer require package"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/rails_migrations_pending.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

const SUGGESTION_REGEX: &str = r"To resolve this issue, run:\s+(.*?)\n";

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(output) = &command.output {
        output.contains("Migrations are pending. To resolve this issue, run:")
    } else {
        false
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(output) = &command.output {
        let migration_script = match Regex::new(SUGGESTION_REGEX).unwrap().captures(output) {
            Some(caps) => caps.get(1).map_or("", |m| m.as_str()),
            None => "",
        };
        vec![system_shell
            .unwrap()
            .and(vec![migration_script, &command.script])]
    } else {
        vec![]
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "rails_migrations_pending".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const OUTPUT_ENV_DEVELOPMENT: &str = r#"
Migrations are pending. To resolve this issue, run:

        rails db:migrate RAILS_ENV=development
"#;

    const OUTPUT_ENV_TEST: &str = r#"
Migrations are pending. To resolve this issue, run:

        bin/rails db:migrate RAILS_ENV=test
"#;

    const OUTPUT_MIGRATIONS_PENDING: &str =
        "\nMigrations are pending. To resolve this issue, run:\n\n        {}\n";

    #[rstest]
    #[case("", OUTPUT_ENV_DEVELOPMENT, true)]
    #[case("", OUTPUT_ENV_TEST, true)]
    #[case(
        "Environment data not found in the schema. To resolve this issue, run: \n\n",
        "",
        false
    )]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("bin/rspec", OUTPUT_ENV_DEVELOPMENT, vec!["rails db:migrate RAILS_ENV=development && bin/rspec"])]
    #[case("bin/rspec", OUTPUT_ENV_TEST, vec!["bin/rails db:migrate RAILS_ENV=test && bin/rspec"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/git_flag_after_filename.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        let error_pattern = Regex::new(r"fatal: bad flag '(.*?)' used after filename").unwrap();
        let error_pattern2 =
            Regex::new(r"fatal: option '(.*?)' must come before non-option arguments").unwrap();
        error_pattern.is_match(output) || error_pattern2.is_match(output)
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(output) = &command.output {
        let error_pattern = Regex::new(r"fatal: bad flag '(.*?)' used after filename").unwrap();
        let error_pattern2 =
            Regex::new(r"fatal: option '(.*?)' must come before non-option arguments").unwrap();
        let mut command_parts = command.script_parts.clone();

        if let Some(caps) = error_pattern
            .captures(output)
            .or_else(|| error_pattern2.captures(output))
        {
            if let Some(bad_flag) = caps.get(1) {
                let bad_flag = bad_flag.as_str();
                if let Some(bad_flag_index) = command_parts.iter().position(|r| r == bad_flag) {
                    for index in (0..bad_flag_index).rev() {
                        if !command_parts[index].starts_with('-') {
                            command_parts.swap(bad_flag_index, index);
                            break;
                        }
                    }
                }
            }
        }

        vec![command_parts.join(" ")]
    } else {
        vec![]
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_flag_after_filename".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case(
        "git log README.md -p",
        "fatal: bad flag '-p' used after filename",
        true
    )]
    #[case(
        "git log README.md -p CONTRIBUTING.md",
        "fatal: bad flag '-p' used after filename",
        true
    )]
    #[case(
        "git log -p README.md --name-only",
        "fatal: bad flag '--name-only' used after filename",
        true
    )]
    #[case(
        "git log README.md -p",
        "fatal: option '-p' must come before non-option arguments",
        true
    )]
    #[case(
        "git log README.md -p CONTRIBUTING.md",
        "fatal: option '-p' must come before non-option arguments",
        true
    )]
    #[case(
        "git log -p README.md --name-only",
        "fatal: option '--name-only' must come before non-option arguments",
        true
    )]
    #[case("git log README.md", "", false)]
    #[case("git log -p README.md", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git log README.md -p", "fatal: bad flag '-p' used after filename", vec!["git log -p README.md"])]
    #[case("git log README.md -p CONTRIBUTING.md", "fatal: bad flag '-p' used after filename", vec!["git log -p README.md CONTRIBUTING.md"])]
    #[case("git log -p README.md --name-only", "fatal: bad flag '--name-only' used after filename", vec!["git log -p --name-only README.md"])]
    #[case("git log README.md -p", "fatal: option '-p' must come before non-option arguments", vec!["git log -p README.md"])]
    #[case("git log README.md -p CONTRIBUTING.md", "fatal: option '-p' must come before non-option arguments", vec!["git log -p README.md CONTRIBUTING.md"])]
    #[case("git log -p README.md --name-only", "fatal: option '--name-only' must come before non-option arguments", vec!["git log -p --name-only README.md"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/git_rm_local_modifications.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains(" rm ")
            && stdout.contains("error: the following file has local modifications")
            && stdout.contains("use --cached to keep the file, or -f to force removal")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(index) = command.script_parts.iter().position(|r| r == "rm") {
        let mut command_parts = command.script_parts.clone();
        command_parts.insert(index + 1, "--cached".to_owned());
        let mut command_list = vec![command_parts.join(" ")];
        command_parts[index + 1] = "-f".to_string();
        command_list.push(command_parts.join(" "));
        return command_list;
    }
    vec![]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_rm_local_modifications".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    fn output(target: &str) -> String {
        format!("error: the following file has local modifications:\n    {target}\n(use --cached to keep the file, or -f to force removal)")
    }

    #[rstest]
    #[case("git rm foo", &output("foo"), true)]
    #[case("git rm foo bar", &output("bar"), true)]
    #[case("git rm foo", "", false)]
    #[case("git rm foo bar", "", false)]
    #[case("git rm", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git rm foo", &output("foo"), vec!["git rm --cached foo", "git rm -f foo"])]
    #[case("git rm foo bar", &output("bar"), vec!["git rm --cached foo bar", "git rm -f foo bar"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_stash.rs
use crate::{
    cli::command::CrabCommand,
    rules::utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
    rules::Rule,
    shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        stdout.contains("or stash them")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![system_shell
        .unwrap()
        .and(vec!["git stash", &command.script])]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_stash".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const CHERRY_PICK_ERROR: &str = "\
error: Your local changes would be overwritten by cherry-pick.\n\
hint: Commit your changes or stash them to proceed.\n\
fatal: cherry-pick failed";

    const REBASE_ERROR: &str = "\
Cannot rebase: Your index contains uncommitted changes.\n\
Please commit or stash them.";

    #[rstest]
    #[case("git cherry-pick a1b2c3d", CHERRY_PICK_ERROR, true)]
    #[case("git rebase -i HEAD~7", REBASE_ERROR, true)]
    #[case("git cherry-pick a1b2c3d", "", false)]
    #[case("git rebase -i HEAD~7", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git cherry-pick a1b2c3d", CHERRY_PICK_ERROR, vec!["git stash && git cherry-pick a1b2c3d"])]
    #[case("git rebase -i HEAD~7", REBASE_ERROR, vec!["git stash && git rebase -i HEAD~7"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/ls_all.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use super::{utils::match_rule_with_is_app, Rule};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.trim().is_empty()
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["ls"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if !command.script_parts.is_empty() {
        let arg = command.script_parts[1..].join(" ");
        vec![match arg.is_empty() {
            true => "ls -A".to_owned(),
            false => format!("ls -A {arg}"),
        }]
    } else {
        Vec::<String>::new()
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "ls_all".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;

    use rstest::rstest;

    #[rstest]
    #[case("ls", "", true)]
    #[case("ls", "file.py\n", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("ls empty_dir", "", vec!["ls -A empty_dir"])]
    #[case("ls", "", vec!["ls -A"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/lein_not_task.rs
use super::{
    get_new_command_without_sudo, match_rule_without_sudo, utils::match_rule_with_is_app, Rule,
};
use crate::{
    cli::command::CrabCommand,
    shell::Shell,
    utils::{get_all_matched_commands, replace_command},
};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command.script_parts.first().is_some_and(|s| s == "lein")
            && output.contains("is not a task. See 'lein help'")
            && output.contains("Did you mean this?")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(
        |command| match_rule_with_is_app(auxiliary_match_rule, command, vec!["lein"], None),
        command,
    )
}

pub fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    if let Some(output) = &command.output {
        let re = Regex::new(r"'([^']*)' is not a task").unwrap();
        let broken_cmd = re
            .captures(output)
            .unwrap()
            .get(1)
            .map_or("", |m| m.as_str());
        let new_cmds = get_all_matched_commands(output, Some(vec!["Did you mean this?"]));
        replace_command(
            command,
            broken_cmd,
            new_cmds.iter().map(|s| s.as_ref()).collect(),
        )
    } else {
        Vec::<String>::new()
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "lein_not_task".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const IS_NOT_TASK: &str =
        "'rpl' is not a task. See 'lein help'.\n\nDid you mean this?\n     repl\n     jar\n";

    #[rstest]
    #[case("lein rpl", IS_NOT_TASK, true)]
    #[case("ls", IS_NOT_TASK, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    // TODO: Fix test issue
    #[case("lein rpl --help", IS_NOT_TASK, vec!["lein repl --help", "lein jar --help"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/mvn_no_command.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains("No goals have been specified for this build")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["mvn"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![
        format!("{} clean package", command.script),
        format!("{} clean install", command.script),
    ]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "mvn_no_command".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const ERROR_NO_GOALS: &str = "[ERROR] No goals have been specified for this build. You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]";

    #[rstest]
    #[case("mvn", ERROR_NO_GOALS, true)]
    #[case("mvn clean", "\n[INFO] Scanning for projects...[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building test 0.2\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ test ---\n[INFO] Deleting /home/mlk/code/test/target\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 0.477s\n[INFO] Finished at: Wed Aug 26 13:05:47 BST 2015\n[INFO] Final Memory: 6M/240M\n[INFO] ------------------------------------------------------------------------", false)]
    #[case("mvn --help", "", false)]
    #[case("mvn -v", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("mvn", ERROR_NO_GOALS, vec!["mvn clean package", "mvn clean install"])]
    #[case("mvn -N", ERROR_NO_GOALS, vec!["mvn -N clean package", "mvn -N clean install"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/mkdir_p.rs
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

use super::{get_new_command_without_sudo, match_rule_without_sudo, Rule};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command.script.contains("mkdir") && output.contains("No such file or directory")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    let re = Regex::new(r"\bmkdir (.*)").unwrap();
    vec![re.replace_all(&command.script, "mkdir -p $1").to_string()]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "mkdir_p.rs".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("mkdir foo/bar/baz", "mkdir: foo/bar: No such file or directory", true)]
    #[case(
        "./bin/hdfs dfs -mkdir foo/bar/baz",
        "mkdir: `foo/bar/baz\': No such file or directory",
        true
    )]
    #[case(
        "hdfs dfs -mkdir foo/bar/baz",
        "mkdir: `foo/bar/baz\': No such file or directory",
        true
    )]
    #[case("mkdir foo/bar/baz", "", false)]
    #[case("mkdir foo/bar/baz", "foo bar baz", false)]
    #[case("hdfs dfs -mkdir foo/bar/baz", "", false)]
    #[case("./bin/hdfs dfs -mkdir foo/bar/baz", "", false)]
    #[case("", "", false)]
    fn test_match(#[case] command: &str, #[case] output: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(output.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("mkdir foo/bar/baz", "", "mkdir -p foo/bar/baz")]
    #[case("hdfs dfs -mkdir foo/bar/baz", "", "hdfs dfs -mkdir -p foo/bar/baz")]
    #[case(
        "./bin/hdfs dfs -mkdir foo/bar/baz",
        "",
        "./bin/hdfs dfs -mkdir -p foo/bar/baz"
    )]
    fn test_get_new_command(#[case] command: &str, #[case] output: &str, #[case] expected: &str) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(output.to_owned()), None);
        assert_eq!(
            get_new_command(&mut command, Some(&system_shell)),
            vec![expected]
        );
    }
}

// FILE: ./src/rules/git_push_without_commits.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        let re = Regex::new(r"src refspec \w+ does not match any").unwrap();
        re.is_match(stdout)
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, _system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![system_shell
        .unwrap()
        .and(vec!["git commit -m \"Initial commit\"", &command.script])]
}

pub fn get_new_command(
    command: &mut CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, _system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_push_without_commits".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case(
        "git push -u origin master",
        "error: src refspec master does not match any\nerror: failed to...",
        true
    )]
    #[case("git push -u origin master", "Everything up-to-date", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git push -u origin master", "error: src refspec master does not match any\nerror: failed to...", vec!["git commit -m \"Initial commit\" && git push -u origin master"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/ln_no_hard_link.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use super::{get_new_command_without_sudo, match_rule_without_sudo, Rule};

use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command.script_parts.first().is_some_and(|s| s == "ln")
            && output.ends_with("hard link not allowed for directory")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(auxiliary_match_rule, command)
}

pub fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    let re = Regex::new(r"^ln ").unwrap();
    vec![re.replace_all(&command.script, "ln -s ").into_owned()]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "ln_no_hard_link".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;

    use rstest::rstest;

    #[rstest]
    #[case(
        "ln barDir barLink",
        "ln: ‘barDir’: hard link not allowed for directory",
        true
    )]
    #[case("sudo ln a b", "ln: ‘a’: hard link not allowed for directory", true)]
    #[case(
        "sudo ln -nbi a b",
        "ln: ‘a’: hard link not allowed for directory",
        true
    )]
    #[case("", "", false)]
    #[case("ln a b", "... hard link", false)]
    #[case("sudo ln a b", "... hard link", false)]
    #[case("a b", "hard link not allowed for directory", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("ln barDir barLink", "", vec!["ln -s barDir barLink"])]
    #[case("sudo ln barDir barLink", "", vec!["sudo ln -s barDir barLink"])]
    #[case("sudo ln -nbi a b", "", vec!["sudo ln -s -nbi a b"])]
    #[case("ln -nbi a b && ls", "", vec!["ln -s -nbi a b && ls"])]
    #[case("ln a ln", "", vec!["ln -s a ln"])]
    #[case("sudo ln a ln", "", vec!["sudo ln -s a ln"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/docker_login.rs
use super::{get_new_command_without_sudo, utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains("docker")
            && output.contains("access denied")
            && output.contains("may require 'docker login'")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["docker"], None)
}

pub fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    vec!["docker login && ".to_owned() + &command.script]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "docker_login".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}
#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const ERR_RESPONSE1: &str = "r#
    Sending build context to Docker daemon  118.8kB
Step 1/6 : FROM foo/bar:fdb7c6d
pull access denied for foo/bar, repository does not exist or may require 'docker login'
#";

    const ERR_RESPONSE2: &str = "r#
    The push refers to repository [artifactory:9090/foo/bar]
push access denied for foo/bar, repository does not exist or may require 'docker login'
#";
    const ERR_RESPONSE3: &str = "r#
    docker push artifactory:9090/foo/bar:fdb7c6d
The push refers to repository [artifactory:9090/foo/bar]
9c29c7ad209d: Preparing
71f3ad53dfe0: Preparing
f58ee068224c: Preparing
aeddc924d0f7: Preparing
c2040e5d6363: Preparing
4d42df4f350f: Preparing
35723dab26f9: Preparing
71f3ad53dfe0: Pushed
cb95fa0faeb1: Layer already exists
#";

    #[rstest]
    #[case(
        "docker build -t artifactory:9090/foo/bar:fdb7c6d .",
        ERR_RESPONSE1,
        true
    )]
    #[case("docker push artifactory:9090/foo/bar:fdb7c6d", ERR_RESPONSE2, true)]
    #[case("docker push artifactory:9090/foo/bar:fdb7c6d", ERR_RESPONSE3, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("docker build -t artifactory:9090/foo/bar:fdb7c6d .", "", vec!["docker login && docker build -t artifactory:9090/foo/bar:fdb7c6d ."])]
    #[case("docker push artifactory:9090/foo/bar:fdb7c6d", "", vec!["docker login && docker push artifactory:9090/foo/bar:fdb7c6d"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/mercurial.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell, utils::get_closest};
use regex::Regex;

fn extract_possibilities(command_output: &str) -> Vec<String> {
    let re1 = Regex::new(r"\n\(did you mean one of ([^\?]+)\?\)").unwrap();
    let re2 = Regex::new(r"\n    ([^$]+)$").unwrap();
    if let Some(caps) = re1.captures(command_output) {
        caps[1]
            .split(", ")
            .map(|s| s.to_string())
            .collect::<Vec<String>>()
    } else if let Some(caps) = re2.captures(command_output) {
        caps[1]
            .split(' ')
            .map(|s| s.to_string())
            .collect::<Vec<String>>()
    } else {
        vec![]
    }
}

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains("hg: unknown command") && output.contains("(did you mean one of ")
            || output.contains("hg: command '") && output.contains("' is ambiguous:")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["hg"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(output) = &command.output {
        let mut script = command.script_parts.clone();
        let possibilities = extract_possibilities(output);
        // script[1]
        if let Some(closest) = get_closest(
            &script[1],
            &possibilities.iter().map(AsRef::as_ref).collect::<Vec<_>>(),
            None,
            None,
        ) {
            script[1] = closest.to_string();
            vec![script.join(" ")]
        } else {
            vec![]
        }
    } else {
        vec![]
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "mercurial".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{extract_possibilities, get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case(
        "hg branchch",
        "hg: unknown command 'branchch'\n(did you mean one of branch, branches?)",
        true
    )]
    #[case(
        "hg vert",
        "hg: unknown command 'vert'\n(did you mean one of revert?)",
        true
    )]
    #[case(
        "hg lgo -r tip",
        "hg: command 're' is ambiguous:\n(did you mean one of log?)",
        true
    )]
    #[case(
        "hg rerere",
        "hg: unknown command 'rerere'\n(did you mean one of revert?)",
        true
    )]
    #[case(
        "hg re",
        "hg: command 're' is ambiguous:\n    rebase recover remove rename resolve revert",
        true
    )]
    #[case(
        "hg re re",
        "hg: command 're' is ambiguous:\n    rebase recover remove rename resolve revert",
        true
    )]
    #[case("hg", "\nMercurial Distributed SCM\n\nbasic commands:", false)]
    #[case(
        "hg asdf",
        "hg: unknown command 'asdf'\nMercurial Distributed SCM\n\nbasic commands:",
        false
    )]
    #[case(
        "hg qwer",
        "hg: unknown command 'qwer'\nMercurial Distributed SCM\n\nbasic commands:",
        false
    )]
    #[case(
        "hg me",
        "\nabort: no repository found in './thefuck' (.hg not found)!",
        false
    )]
    #[case(
        "hg reb",
        "\nabort: no repository found in './thefuck' (.hg not found)!",
        false
    )]
    #[case(
        "hg co",
        "\nabort: no repository found in './thefuck' (.hg not found)!",
        false
    )]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("hg: unknown command 'base'\n(did you mean one of blame, phase, rebase?)", vec!["blame", "phase", "rebase"])]
    #[case("hg: unknown command 'branchch'\n(did you mean one of branch, branches?)", vec!["branch", "branches"])]
    #[case("hg: unknown command 'vert'\n(did you mean one of revert?)", vec!["revert"])]
    #[case("hg: command 're' is ambiguous:\n(did you mean one of log?)", vec!["log"])]
    #[case("hg: unknown command 'rerere'\n(did you mean one of revert?)", vec!["revert"])]
    #[case("hg: command 're' is ambiguous:\n    rebase recover remove rename resolve revert", vec!["rebase", "recover", "remove", "rename", "resolve", "revert"])]
    #[case("hg: command 're' is ambiguous:\n    rebase recover remove rename resolve revert", vec!["rebase", "recover", "remove", "rename", "resolve", "revert"])]
    fn test_extract_possibilities(#[case] stdout: &str, #[case] possibilities: Vec<&str>) {
        assert_eq!(extract_possibilities(stdout), possibilities)
    }

    #[rstest]
    #[case("hg base", "hg: unknown command 'base'\n(did you mean one of blame, phase, rebase?)", vec!["hg rebase"])]
    #[case("hg branchch", "hg: unknown command 'branchch'\n(did you mean one of branch, branches?)", vec!["hg branch"])]
    #[case("hg vert", "hg: unknown command 'vert'\n(did you mean one of revert?)", vec!["hg revert"])]
    #[case("hg lgo -r tip", "hg: command 're' is ambiguous:\n(did you mean one of log?)", vec!["hg log -r tip"])]
    #[case("hg rerere", "hg: unknown command 'rerere'\n(did you mean one of revert?)", vec!["hg revert"])]
    #[case("hg re", "hg: command 're' is ambiguous:\n    rebase recover remove rename resolve revert", vec!["hg rebase"])]
    #[case("hg re re", "hg: command 're' is ambiguous:\n    rebase recover remove rename resolve revert", vec!["hg rebase re"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/python_module_error.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

const MISSING_MODULE: &str = r"ModuleNotFoundError: No module named '([^']+)'";

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(output) = &command.output {
        output.contains("ModuleNotFoundError: No module named '")
    } else {
        false
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(output) = &command.output {
        let missing_module = Regex::new(MISSING_MODULE)
            .unwrap()
            .captures(output)
            .and_then(|caps| caps.get(1).map(|m| m.as_str().to_owned()))
            .unwrap_or("".to_owned());
        vec![system_shell.unwrap().and(vec![
            &format!("pip install {missing_module}"),
            &command.script,
        ])]
    } else {
        vec![]
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "python_module_error".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    fn module_error_output(filename: &str, module_name: &str) -> String {
        format!("Traceback (most recent call last):\n  File \"{filename}\", line 1, in <module>\n    import {module_name}\nModuleNotFoundError: No module named '{module_name}'")
    }

    #[rstest]
    #[case("./some_other_script.py", &module_error_output("some_other_script.py", "a_module"), true)]
    #[case("python some_script.py", &module_error_output("some_script.py", "more_itertools"), true)]
    #[case("python hello_world.py", "Hello World", false)]
    #[case("./hello_world.py", "Traceback (most recent call last):\n  File \"hello_world.py\", line 1, in <module>\n    pritn(\"Hello World\")\nNameError: name 'pritn' is not defined", false)]
    fn test_not_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("./some_other_script.py", &module_error_output("some_other_script.py", "a_module"), vec!["pip install a_module && ./some_other_script.py"])]
    #[case("python some_script.py", &module_error_output("some_script.py", "more_itertools"), vec!["pip install more_itertools && python some_script.py"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_string()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/docker_image_being_used_by_container.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains("image is being used by running container")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["docker"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let container_id = command
        .output
        .as_ref()
        .unwrap()
        .trim()
        .split(' ')
        .next_back()
        .unwrap();
    vec![format!(
        "docker container rm -f {} && {}",
        container_id, command.script
    )]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "docker_image_being_used_by_container".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const ERR_RESPONSE: &str = "Error response from daemon: conflict: unable to delete cd809b04b6ff (cannot be forced) - image is being used by running container e5e2591040d1";

    #[rstest]
    #[case("docker image rm -f cd809b04b6ff", ERR_RESPONSE, true)]
    #[case(
        "docker image rm -f cd809b04b6ff",
        "bash: docker: command not found",
        false
    )]
    #[case("git image rm -f cd809b04b6ff", ERR_RESPONSE, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("docker image rm -f cd809b04b6ff", ERR_RESPONSE, vec!["docker container rm -f e5e2591040d1 && docker image rm -f cd809b04b6ff"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_push_different_branch_names.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("push")
            && stdout.contains("The upstream branch of your current branch does not match")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, _system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(stdout) = &command.output {
        let re = Regex::new(r"(?m)^ +(git push [^\s]+ [^\s]+)").unwrap();
        let new_command = re
            .captures_iter(stdout)
            .next()
            .map(|cap| cap[1].to_string());
        match new_command {
            Some(new_command) => vec![new_command],
            None => vec![],
        }
    } else {
        vec![]
    }
}

pub fn get_new_command(
    command: &mut CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, _system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_push_different_branch_names".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const OUTPUT: &str = r#"
fatal: The upstream branch of your current branch does not match
the name of your current branch.  To push to the upstream branch
on the remote, use

    git push origin HEAD:%s

To push to the branch of the same name on the remote, use

    git push origin %s

To choose either option permanently, see push.default in 'git help config'.
"#;

    fn error_msg(localbranch: &str, remotebranch: &str) -> String {
        OUTPUT
            .replace("%s", remotebranch)
            .replace("%s", localbranch)
    }

    #[rstest]
    #[case("git push", &error_msg("foo", "bar"), true)]
    #[case("vim", "", false)]
    #[case("git status", &error_msg("foo", "bar"), false)]
    #[case("git push", "", false)]
    fn test_match(#[case] command: &str, #[case] output: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(output.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git push", &error_msg("foo", "bar"), vec!["git push origin HEAD:bar"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] output: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(output.to_owned()), None);
        assert_eq!(
            get_new_command(&mut command, Some(&system_shell)),
            expected.iter().map(|&s| s.to_owned()).collect::<Vec<_>>()
        );
    }
}

// FILE: ./src/rules/chmod_x.rs
use crate::{cli::command::CrabCommand, shell::Shell};
use is_executable::IsExecutable;

use std::path::Path;

use super::Rule;

fn _match_rule(
    command: &mut CrabCommand,
    mock_file_exists: Option<bool>,
    mock_file_access: Option<bool>,
) -> bool {
    if let Some(stdout) = &command.output {
        command.script.starts_with("./")
            && stdout.to_lowercase().contains("permission denied")
            && {
                if let Some(file_exists) = mock_file_exists {
                    file_exists
                } else {
                    Path::new(command.script_parts[0].as_str()).exists()
                }
            }
            && {
                if let Some(file_access) = mock_file_access {
                    !file_access
                } else {
                    let path = Path::new(&command.script_parts[0]);
                    !path.is_executable()
                }
            }
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    _match_rule(command, None, None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![system_shell.unwrap().and(vec![
        format!("chmod +x {}", &command.script_parts[0][2..]).as_str(),
        &command.script,
    ])]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "chmod_x".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{_match_rule, get_new_command};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;

    macro_rules! parameterized_match_rule_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout, file_exists, file_access) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert!(_match_rule(&mut command, file_exists, file_access));
                }
            )*
        }
    }

    macro_rules! parameterized_unmatch_rule_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout, file_exists, file_access) = $value;
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert!(!_match_rule(&mut command, file_exists, file_access));
                }
            )*
        }
    }

    macro_rules! parameterized_get_new_command_tests {
        ($($name:ident: $value:expr,)*) => {
            $(
                #[test]
                fn $name() {
                    let (script, stdout, expected) = $value;
                    let system_shell = Bash{};
                    let mut command = CrabCommand::new(
                                script.to_owned(),
                                Some(stdout.to_owned()),
                                None
                            );
                    assert_eq!(get_new_command(&mut command, Some(&system_shell))[0], expected);
                }
            )*
        }
    }

    parameterized_match_rule_tests! {
        match_rule_1: ("./gradlew build", "gradlew: Permission denied", Some(true), Some(false)),
        match_rule_2: ("./install.sh --help", "install.sh: permission denied", Some(true), Some(false)),
    }

    parameterized_unmatch_rule_tests! {
        unmatch_rule_1: ("./gradlew build", "gradlew: Permission denied", Some(true), Some(true)),
        unmatch_rule_2: ("./gradlew build", "gradlew: Permission denied", Some(false), Some(false)),
        unmatch_rule_3: ("./gradlew build", "gradlew: error", Some(true), Some(false)),
        unmatch_rule_4: ("gradlew build", "gradlew: Permission denied", Some(true), Some(false)),
    }

    parameterized_get_new_command_tests! {
        get_new_command_1: ("./gradlew build", "", "chmod +x gradlew && ./gradlew build"),
        get_new_command_2: ("./install.sh --help", "", "chmod +x install.sh && ./install.sh --help"),
    }
}

// FILE: ./src/rules/rm_dir.rs
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

use super::{get_new_command_without_sudo, match_rule_without_sudo, Rule};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("rm ") && stdout.to_lowercase().contains("is a directory")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    let re = Regex::new(r"\brm (.*)").unwrap();
    let repl = |caps: &regex::Captures| {
        let arguments = if command.script.contains("hdfs") {
            "-r"
        } else {
            "-rf"
        };
        format!("rm {} {}", arguments, &caps[1])
    };
    vec![re.replace(&command.script, repl).to_string()]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "rm_dir".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;

    use rstest::rstest;

    #[rstest]
    #[case("rm foo", "rm: foo: is a directory", true)]
    #[case("rm foo", "rm: foo: Is a directory", true)]
    #[case("hdfs dfs -rm foo", "rm: `foo`: Is a directory", true)]
    #[case("./bin/hdfs dfs -rm foo", "rm: `foo`: Is a directory", true)]
    #[case("rm foo", "", false)]
    #[case("hdfs dfs -rm foo", "", false)]
    #[case("./bin/hdfs dfs -rm foo", "", false)]
    #[case("", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("rm foo", "", vec!["rm -rf foo"])]
    #[case("hdfs dfs -rm foo", "", vec!["hdfs dfs -rm -r foo"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/php_s.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    command.script_parts.contains(&"-s".to_owned())
        && command.script_parts.last().unwrap_or(&"".to_owned()) != &"-s".to_owned()
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["php"], Some(2))
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command.script.replace("-s", "-S")]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "php_s".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("php -s localhost:8000", "", true)]
    #[case("php -t pub -s 0.0.0.0:8080", "", true)]
    #[case("php -S localhost:8000", "", false)]
    #[case("vim php -s", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("php -s localhost:8000", "", vec!["php -S localhost:8000"])]
    #[case("php -t pub -s 0.0.0.0:8080", "", vec!["php -t pub -S 0.0.0.0:8080"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/cat_dir.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use std::path::Path;

fn is_dir(path: &str) -> bool {
    Path::new(path).is_dir()
}

fn auxiliary_match_rule<F>(command: &CrabCommand, fn_is_dir: F) -> bool
where
    F: Fn(&str) -> bool,
{
    if let Some(output) = &command.output {
        if command.script_parts.len() > 1 {
            output.starts_with("cat: ") && fn_is_dir(&command.script_parts[1])
        } else {
            false
        }
    } else {
        false
    }
}

fn mockable_match_rule<F>(
    command: &mut CrabCommand,
    system_shell: Option<&dyn Shell>,
    fn_is_dir: F,
) -> bool
where
    F: Fn(&str) -> bool,
{
    match_rule_with_is_app(
        |command| auxiliary_match_rule(command, &fn_is_dir),
        command,
        vec!["cat"],
        Some(1),
    )
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    mockable_match_rule(command, system_shell, is_dir)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command.script.replacen("cat", "ls", 1)]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "cat_dir".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, mockable_match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    fn is_dir_true(path: &str) -> bool {
        true
    }
    fn is_dir_false(path: &str) -> bool {
        false
    }

    #[rstest]
    #[case("cat foo", "cat: foo: Is a directory\n", true)]
    #[case("cat /foo/bar/", "cat: /foo/bar/: Is a directory\n", true)]
    #[case("cat cat", "cat: cat/: Is a directory\n", true)]
    #[case("cat foo", "foo bar baz", false)]
    #[case("cat foo bar", "foo bar baz", false)]
    #[case("notcat foo bar", "some output", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(
            mockable_match_rule(
                &mut command,
                None,
                match is_match {
                    true => is_dir_true,
                    false => is_dir_false,
                }
            ),
            is_match
        );
    }

    #[rstest]
    #[case("cat foo", "cat: foo: Is a directory\n", vec!["ls foo"])]
    #[case("cat /foo/bar/", "cat: /foo/bar/: Is a directory\n", vec!["ls /foo/bar/"])]
    #[case("cat cat", "cat: cat/: Is a directory\n", vec!["ls cat"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_merge.rs
use super::{utils::git::get_new_command_with_git_support, Rule};
use crate::utils::replace_argument;
use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("merge")
            && stdout.contains(" - not something we can merge")
            && stdout.contains("Did you mean this?")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(stdout) = &command.output {
        let re_unknown_branch = Regex::new(r"merge: (.+) - not something we can merge").unwrap();
        let re_remote_branch = Regex::new(r"Did you mean this\?\n\t([^\n]+)").unwrap();
        if let Some(unknown_branch) = re_unknown_branch.captures(stdout) {
            if let Some(remote_branch) = re_remote_branch.captures(stdout) {
                vec![replace_argument(
                    &command.script,
                    &unknown_branch[1],
                    &remote_branch[1],
                )]
            } else {
                Vec::<String>::new()
            }
        } else {
            Vec::<String>::new()
        }
    } else {
        Vec::<String>::new()
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_merge".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use crate::{parameterized_get_new_command_tests, parameterized_match_rule_tests};

    const OUTPUT: &str =
        "merge: local - not something we can merge\n\nDid you mean this?\n\tremote/local";

    parameterized_match_rule_tests! {
        match_rule,
        match_rule_01: ("git merge test", OUTPUT, true),
        unmatch_rule_01: ("git merge master", "", false),
        unmatch_rule_02: ("ls", OUTPUT, false),
    }

    parameterized_get_new_command_tests! {
        get_new_command,
        get_new_command_1: ("git merge local", OUTPUT, "git merge remote/local"),
        get_new_command_2: ("git merge -m \"test\" local", OUTPUT, "git merge -m \"test\" remote/local"),
        get_new_command_3: ("git merge -m \"test local\" local", OUTPUT, "git merge -m \"test local\" remote/local"),
    }
}

// FILE: ./src/rules/git_rebase_no_changes.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script_parts.contains(&"rebase".to_owned())
            && command.script_parts.contains(&"--continue".to_owned())
            && stdout.contains("No changes - did you forget to use 'git add'?")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, _system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec!["git rebase --skip".to_owned()]
}

pub fn get_new_command(
    command: &mut CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, _system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_rebase_no_changes".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const OUTPUT: &str = "Applying: Test commit\nNo changes - did you forget to use 'git add'?\nIf there is nothing left to stage, chances are that something else\nalready introduced the same changes; you might want to skip this patch.\n\nWhen you have resolved this problem, run \"git rebase --continue\".\nIf you prefer to skip this patch, run \"git rebase --skip\" instead.\nTo check out the original branch and stop rebasing, run \"git rebase --abort\".\n";

    #[rstest]
    #[case("git rebase --continue", OUTPUT, true)]
    #[case("git rebase --continue", "", false)]
    #[case("git rebase --skip", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git rebase --continue", OUTPUT, vec!["git rebase --skip"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/npm_run_script.rs
use super::{
    utils::{
        match_rule_with_is_app,
        npm::{mockable_get_scripts, run_npm_command},
    },
    Rule,
};
use crate::{cli::command::CrabCommand, shell::Shell};

fn mockable_match_rule<F>(command: &CrabCommand, fn_run_npm_command: F) -> bool
where
    F: Fn() -> Vec<u8>,
{
    if let Some(output) = &command.output {
        println!("{:?}", output.contains("Usage: npm <command>"));
        println!(
            "{:?}",
            !command
                .script_parts
                .iter()
                .any(|part| part.starts_with("ru"))
        );
        println!("{:?}", mockable_get_scripts(&fn_run_npm_command));
        println!("{:?}", &command.script_parts[1]);
        println!(
            "{:?}",
            mockable_get_scripts(&fn_run_npm_command).contains(&command.script_parts[1])
        );

        output.contains("Usage: npm <command>")
            && !command
                .script_parts
                .iter()
                .any(|part| part.starts_with("ru"))
            && mockable_get_scripts(fn_run_npm_command).contains(&command.script_parts[1])
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(
        |command| mockable_match_rule(command, run_npm_command),
        command,
        vec!["npm"],
        None,
    )
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let mut parts = command.script_parts.clone();
    parts.insert(1, "run-script".to_owned());
    vec![parts.join(" ")]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "npm_run_script".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, mockable_match_rule};
    use crate::cli::command::CrabCommand;
    use crate::rules::utils::match_rule_with_is_app;
    use crate::shell::Bash;
    use rstest::rstest;

    const OUTPUT: &str = r#"Usage: npm <command>

where <command> is one of:
    access, add-user, adduser, apihelp, author, bin, bugs, c,
    cache, completion, config, ddp, dedupe, deprecate, dist-tag,
    dist-tags, docs, edit, explore, faq, find, find-dupes, get,
    help, help-search, home, i, info, init, install, issues, la,
    link, list, ll, ln, login, logout, ls, outdated, owner,
    pack, ping, prefix, prune, publish, r, rb, rebuild, remove,
    repo, restart, rm, root, run-script, s, se, search, set,
    show, shrinkwrap, star, stars, start, stop, t, tag, team,
    test, tst, un, uninstall, unlink, unpublish, unstar, up,
    update, upgrade, v, version, view, whoami

npm <cmd> -h     quick help on <cmd>
npm -l           display full usage info
npm faq          commonly asked questions
npm help <term>  search for help on <term>
npm help npm     involved overview

Specify configs in the ini-formatted file:
    /home/nvbn/.npmrc
or on the command line via: npm <command> --key value
Config info can be viewed via: npm help config"#;

    const RUN_SCRIPT_STDOUT: &[u8] = b"
Lifecycle scripts included in code-view-web:
  test
    jest

available via `npm run-script`:
  build
    cp node_modules/ace-builds/src-min/ -a resources/ace/ && webpack --progress --colors -p --config ./webpack.production.config.js
  develop
    cp node_modules/ace-builds/src/ -a resources/ace/ && webpack-dev-server --progress --colors
  watch-test
    jest --verbose --watch";

    fn mocked_run_npm_command() -> Vec<u8> {
        RUN_SCRIPT_STDOUT.to_vec()
    }

    #[rstest]
    #[case("npm watch-test", OUTPUT, true)]
    #[case("npm develop", OUTPUT, true)]
    #[case("npm test", "TEST FAIL", false)]
    #[case("npm watch-test", "TEST FAIL", false)]
    #[case("npm test", OUTPUT, false)]
    #[case("vim watch-test", OUTPUT, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(
            match_rule_with_is_app(
                |command| mockable_match_rule(command, mocked_run_npm_command),
                &command,
                vec!["npm"],
                None,
            ),
            is_match
        );
    }

    #[rstest]
    #[case("npm watch-test", OUTPUT, vec!["npm run-script watch-test"])]
    #[case("npm -i develop", OUTPUT, vec!["npm run-script -i develop"])]
    #[case("npm -i watch-script --path ..", OUTPUT, vec!["npm run-script -i watch-script --path .."])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/go_run.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    command.script.starts_with("go run ") && !command.script.ends_with(".go")
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["go"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![command.script.clone() + ".go"]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "go_run".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("go run foo", "", true)]
    #[case("go run bar", "", true)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("go run foo", "", vec!["go run foo.go"])]
    #[case("go run bar", "", vec!["go run bar.go"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_checkout.rs
use super::{utils::git::get_new_command_with_git_support, Rule};
use crate::utils::replace_argument;
use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
    utils::get_closest,
};
use regex::Regex;

use std::process::Command;
use std::str;

fn get_branches(mock_output: Option<&str>) -> Vec<String> {
    let mut stdout: String;
    if let Some(mock_output_str) = mock_output {
        stdout = mock_output_str.to_owned();
    } else {
        let output = Command::new("git")
            .args(["branch", "-a", "--no-color", "--no-column"])
            .output()
            .expect("Failed to execute command");
        stdout = str::from_utf8(&output.stdout).unwrap().to_owned();
    }

    let mut branches = Vec::new();

    for line in stdout.lines() {
        if line.contains("->") {
            // Remote HEAD like '  remotes/origin/HEAD -> origin/master'
            continue;
        }
        let mut line = line.to_string();
        if line.starts_with('*') {
            line = line.split_whitespace().nth(1).unwrap().to_string();
        }
        if line.trim().starts_with("remotes/") {
            line = line.split('/').skip(2).collect::<Vec<&str>>().join("/");
        }
        branches.push(line.trim().to_string());
    }

    branches
}

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        stdout.contains("did not match any file(s) known to git")
            && !stdout.contains("Did you forget to 'git add'?")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn mockable_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
    mock_output: Option<&str>,
) -> Vec<String> {
    if let Some(stdout) = &command.output {
        let re = Regex::new(r"error: pathspec '([^']*)' did not match any file\(s\) known to git")
            .unwrap();
        if let Some(caps) = re.captures(stdout) {
            let missing_file = caps.get(1).map_or("", |m| m.as_str());

            let branches = get_branches(mock_output);
            let branches: Vec<&str> = branches.iter().map(|s| s.as_str()).collect();
            let closest_branch = get_closest(missing_file, &branches, None, Some(false));

            let mut new_commands = Vec::new();

            if let Some(closest_branch) = closest_branch {
                new_commands.push(replace_argument(
                    &command.script,
                    missing_file,
                    closest_branch,
                ));
            }
            if command.script_parts.len() > 1 && command.script_parts[1] == "checkout" {
                new_commands.push(replace_argument(&command.script, "checkout", "checkout -b"));
            }

            if new_commands.is_empty() {
                new_commands.push(
                    system_shell
                        .unwrap()
                        .and(vec![&format!("git branch {missing_file}"), &command.script]),
                );
            }
            new_commands
        } else {
            Vec::<String>::new()
        }
    } else {
        Vec::<String>::new()
    }
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    mockable_get_new_command(command, system_shell, None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_checkout".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_branches, match_rule, mockable_get_new_command};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;

    use rstest::rstest;
    use std::str;

    fn did_not_match(target: &str, did_you_forget: bool) -> String {
        let mut error =
            format!("error: pathspec '{target}' did not match any file(s) known to git.");
        if did_you_forget {
            error = format!("{error}\nDid you forget to 'git add'?'");
        }
        error
    }

    #[rstest]
    #[case("git checkout unknown", did_not_match("unknown", false))]
    #[case("git commit unknown", did_not_match("unknown", false))]
    fn test_match(#[case] command: &str, #[case] output: String) {
        let crab_command = &mut CrabCommand::new(command.to_owned(), Some(output), None);
        assert!(match_rule(crab_command, None));
    }

    #[rstest]
    #[case("git submodule update unknown", did_not_match("unknown", true))]
    #[case("git checkout known", "")]
    #[case("git commit known", "")]
    fn test_not_match(#[case] command: &str, #[case] output: String) {
        let crab_command = &mut CrabCommand::new(command.to_owned(), Some(output), None);
        assert!(!match_rule(crab_command, None));
    }

    #[rstest]
    #[case("", vec![])]
    #[case("* master", vec!["master"])]
    #[case("  remotes/origin/master", vec!["master"])]
    #[case("  remotes/origin/test/1", vec!["test/1"])]
    #[case("  remotes/origin/test/1/2/3", vec!["test/1/2/3"])]
    #[case("  test/1", vec!["test/1"])]
    #[case("  test/1/2/3", vec!["test/1/2/3"])]
    #[case("  remotes/origin/HEAD -> origin/master", vec![])]
    #[case("  just-another-branch", vec!["just-another-branch"])]
    #[case("* master\n  just-another-branch", vec!["master", "just-another-branch"])]
    #[case("* master\n  remotes/origin/master\n  just-another-branch", vec!["master", "master", "just-another-branch"])]
    fn test_get_branches(#[case] branches: String, #[case] branch_list: Vec<&str>) {
        assert_eq!(get_branches(Some(&branches)), branch_list)
    }

    #[rstest]
    #[case(
        "",
        "git checkout unknown",
        did_not_match("unknown", false),
        vec!["git checkout -b unknown"]
    )]
    #[case(
        "",
        "git commit unknown",
        did_not_match("unknown", false),
        vec!["git branch unknown && git commit unknown"]
    )]
    #[case(
        "  test-random-branch-123",
        "git checkout tst-rdm-brnch-123",
        did_not_match("tst-rdm-brnch-123", false),
            vec![
                "git checkout test-random-branch-123",
                "git checkout -b tst-rdm-brnch-123",
            ]
    )]
    #[case(
        "  test-random-branch-123",
        "git commit tst-rdm-brnch-123", did_not_match("tst-rdm-brnch-123", false),
        vec!["git commit test-random-branch-123"]
    )]
    fn test_get_new_command(
        #[case] branches: String,
        #[case] command: String,
        #[case] output: String,
        #[case] new_command: Vec<&str>,
    ) {
        let crab_command = &mut CrabCommand::new(command.to_owned(), Some(output), None);
        let system_shell = Bash {};
        assert_eq!(
            mockable_get_new_command(crab_command, Some(&system_shell), Some(&branches)),
            new_command
        );
    }
}

// FILE: ./src/rules/git_push_force.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
    utils::replace_argument,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("push")
            && stdout.contains("! [rejected]")
            && stdout.contains("failed to push some refs to")
            && stdout
                .contains("Updates were rejected because the tip of your current branch is behind")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, _system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![replace_argument(
        &command.script,
        "push",
        "push --force-with-lease",
    )]
}

pub fn get_new_command(
    command: &mut CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, _system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_push_force".to_owned(),
        Some(false),
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const GIT_ERR: &str = "\
To /tmp/foo\n\
 ! [rejected]        master -> master (non-fast-forward)\n\
 error: failed to push some refs to '/tmp/bar'\n\
 hint: Updates were rejected because the tip of your current branch is behind\n\
 hint: its remote counterpart. Integrate the remote changes (e.g.\n\
 hint: 'git pull ...') before pushing again.\n\
 hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n";

    const GIT_UPTODATE: &str = "Everything up-to-date";
    const GIT_OK: &str = "\
Counting objects: 3, done.\n\
Delta compression using up to 4 threads.\n\
Compressing objects: 100% (2/2), done.\n\
Writing objects: 100% (3/3), 282 bytes | 0 bytes/s, done.\n\
Total 3 (delta 0), reused 0 (delta 0)\n\
To /tmp/bar\n\
   514eed3..f269c79  master -> master\n";

    #[rstest]
    #[case("git push", GIT_ERR, true)]
    #[case("git push nvbn", GIT_ERR, true)]
    #[case("git push nvbn master", GIT_ERR, true)]
    #[case("git push", GIT_OK, false)]
    #[case("git push", GIT_UPTODATE, false)]
    #[case("git push nvbn", GIT_OK, false)]
    #[case("git push nvbn master", GIT_UPTODATE, false)]
    fn test_match(#[case] command: &str, #[case] output: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(output.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git push", GIT_ERR, vec!["git push --force-with-lease"])]
    #[case("git push nvbn", GIT_ERR, vec!["git push --force-with-lease nvbn"])]
    #[case("git push nvbn master", GIT_ERR, vec!["git push --force-with-lease nvbn master"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] output: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(output.to_owned()), None);
        assert_eq!(
            get_new_command(&mut command, Some(&system_shell)),
            expected.iter().map(|&s| s.to_owned()).collect::<Vec<_>>()
        );
    }
}

// FILE: ./src/rules/utils/mod.rs
use crate::cli::command::CrabCommand;
use std::path::Path;

pub mod git;
pub mod npm;
pub mod parameterized_tests;

/// Matches a rule with a given command if it is an application.
///
/// # Arguments
///
/// * `func` - Match function that takes a `CrabCommand` and returns a boolean.
/// * `command` - A reference to a `CrabCommand` instance.
/// * `app_names` - A vector of application names to check against.
/// * `at_least` - An optional usize that specifies the minimum number of script parts.
///
/// # Returns
///
/// * `bool` - Returns true if the command matches the rule and is an application, false otherwise.
pub fn match_rule_with_is_app<F>(
    func: F,
    command: &CrabCommand,
    app_names: Vec<&str>,
    at_least: Option<usize>,
) -> bool
where
    F: Fn(&CrabCommand) -> bool,
{
    if is_app(command, app_names, at_least) {
        func(command)
    } else {
        false
    }
}

/// Checks if a given command is an application.
///
/// # Arguments
///
/// * `command` - A reference to a `CrabCommand` instance.
/// * `app_names` - A vector of application names to check against.
/// * `at_least` - An optional usize that specifies the minimum number of script parts.
///
/// # Returns
///
/// * `bool` - Returns true if the command is an application, false otherwise.
fn is_app(command: &CrabCommand, app_names: Vec<&str>, at_least: Option<usize>) -> bool {
    let at_least = at_least.unwrap_or(0);
    if command.script_parts.len() > at_least {
        let app_name = Path::new(&command.script_parts[0])
            .file_name()
            .and_then(|os_str| os_str.to_str())
            .unwrap_or("");
        return app_names.contains(&app_name);
    }

    false
}

// FILE: ./src/rules/utils/git.rs
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;
use shlex::split as shlex_split;
use shlex::Quoter;

use super::is_app;

/// Provides git support for a given function.
///
/// # Arguments
///
/// * `func` - A function that takes a `CrabCommand` instance and returns a boolean.
/// * `command` - A mutable `CrabCommand` instance.
///
/// # Returns
///
/// * `bool` - Returns the result of the function `func`.
pub fn match_rule_with_git_support<F>(func: F, command: &mut CrabCommand) -> bool
where
    F: Fn(&CrabCommand) -> bool,
{
    // supports GitHub's `hub` command
    // which is recommended to be used with `alias git=hub`
    // but at this point, shell aliases have already been resolved
    if !is_app(command, vec!["git", "hub"], None) {
        return false;
    }

    // perform git aliases expansion
    if let Some(stdout) = &command.output {
        if stdout.contains("trace: alias expansion:") {
            let re = Regex::new(r"trace: alias expansion: ([^ ]*) => ([^\n]*)").unwrap();
            if let Some(search) = re.captures(stdout) {
                let alias = search.get(1).map_or("", |m| m.as_str());

                // by default git quotes everything, for example:
                //     'commit' '--amend'
                // which is surprising and does not allow to easily test for
                // eg. 'git commit'
                let expansion = search
                    .get(2)
                    .map_or("", |m| m.as_str())
                    .split_whitespace()
                    .map(|part| format!("\"{part}\"")) // shell.quote(part)
                    .collect::<Vec<_>>()
                    .join(" ");
                let new_script = command.script.replace(&format!(r"\b{alias}\b"), &expansion);

                command.script = new_script;
            }
        }
    }

    func(command)
}

pub fn get_new_command_with_git_support<F>(
    func: F,
    command: &mut CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String>
where
    F: Fn(&CrabCommand, Option<&dyn Shell>) -> Vec<String>,
{
    // supports GitHub's `hub` command
    // which is recommended to be used with `alias git=hub`
    // but at this point, shell aliases have already been resolved
    if !is_app(command, vec!["git", "hub"], None) {
        return Vec::<String>::new();
    }
    let mut new_command = command;

    // perform git aliases expansion
    if let Some(stdout) = &new_command.output {
        if stdout.contains("trace: alias expansion:") {
            let re = Regex::new(r"trace: alias expansion: ([^ ]*) => ([^\n]*)").unwrap();
            if let Some(search) = re.captures(stdout) {
                let shlex_quoter = Quoter::new();
                let alias = search.get(1).map_or("", |m| m.as_str());

                // by default git quotes everything, for example:
                //     'commit' '--amend'
                // which is surprising and does not allow to easily test for
                // eg. 'git commit'
                let expansion = search.get(2).map_or("", |m| m.as_str());
                let expansion = shlex_split(expansion)
                    .unwrap()
                    .iter()
                    .map(|s| shlex_quoter.quote(s).unwrap())
                    .collect::<Vec<_>>()
                    .join(" ");

                let re = Regex::new(&format!(r"\b{alias}\b")).unwrap();
                let new_script = re.replace(&new_command.script, &expansion);

                *new_command = new_command.update(Some(new_script.to_string()), None, None);
            }
        }
    }

    func(new_command, system_shell)
}

#[cfg(test)]
mod tests {
    use super::{get_new_command_with_git_support, is_app, match_rule_with_git_support};
    use crate::cli::command::CrabCommand;
    use crate::shell::Shell;
    use rstest::rstest;

    #[rstest]
    #[case("/usr/bin/git diff", vec!["git", "hub"], None, true)]
    #[case("/bin/hdfs dfs -rm foo", vec!["hdfs"], None, true)]
    #[case("git diff", vec!["git", "hub"], None, true)]
    #[case("hub diff", vec!["git", "hub"], None, true)]
    #[case("hg diff", vec!["git", "hub"], None, false)]
    #[case("/path/to/app run", vec!["app"], Some(1), true)]
    #[case("/path/to/app run", vec!["app"], Some(0), true)]
    #[case("/path/to/app", vec!["app"], None, true)]
    #[case("/path/to/app", vec!["app"], Some(0), true)]
    #[case("/path/to/app", vec!["app"], Some(1), false)]
    fn test_is_app(
        #[case] script: &str,
        #[case] app_names: Vec<&str>,
        #[case] at_least: Option<usize>,
        #[case] is_app_bool: bool,
    ) {
        let mut command = CrabCommand::new(script.to_owned(), None, None);
        assert_eq!(is_app(&command, app_names, at_least), is_app_bool);
    }

    #[rstest]
    #[case(
        "git co",
        "19:22:36.299340 git.c:282   trace: alias expansion: co => 'checkout'",
        "git checkout"
    )]
    #[case(
        "git com file",
        "19:23:25.470911 git.c:282   trace: alias expansion: com => 'commit' '--verbose'",
        "git commit --verbose file"
    )]
    #[case(
        "git com -m \"Initial commit\"",
        "19:22:36.299340 git.c:282   trace: alias expansion: com => \"commit\"",
        "git commit -m \"Initial commit\""
    )]
    #[case(
        "git br -d some_branch",
        "19:22:36.299340 git.c:282   trace: alias expansion: br => 'branch'",
        "git branch -d some_branch"
    )]
    fn test_get_command_with_git_support(
        #[case] script: &str,
        #[case] output: &str,
        #[case] expected: &str,
    ) {
        let mut command = CrabCommand::new(script.to_owned(), Some(output.to_owned()), None);
        let func =
            |command: &CrabCommand, shell: Option<&dyn Shell>| vec![command.script.to_owned()];
        assert_eq!(
            get_new_command_with_git_support(func, &mut command, None),
            vec![expected]
        );
    }

    #[rstest]
    #[case("git pull", Some("".to_string()), true)]
    #[case("hub pull", Some("".to_owned()), true)]
    #[case("git push --set-upstream origin foo", Some("".to_owned()), true)]
    #[case("hub push --set-upstream origin foo", Some("".to_owned()), true)]
    #[case("ls", Some("".to_owned()), false)]
    #[case("cat git", Some("".to_owned()), false)]
    #[case("cat hub", Some("".to_owned()), false)]
    #[case("git pull", None, true)]
    #[case("hub pull", None, true)]
    #[case("git push --set-upstream origin foo", None, true)]
    #[case("hub push --set-upstream origin foo", None, true)]
    #[case("ls", None, false)]
    #[case("cat git", None, false)]
    #[case("cat hub", None, false)]
    fn test_match_rule_with_git_support(
        #[case] script: &str,
        #[case] output: Option<String>,
        #[case] is_git_command: bool,
    ) {
        let mut command = CrabCommand::new(script.to_owned(), output, None);
        let func = |command: &CrabCommand| true;
        assert_eq!(
            match_rule_with_git_support(func, &mut command),
            is_git_command
        );
    }
}

// FILE: ./src/rules/utils/parameterized_tests.rs
#[macro_export]
macro_rules! parameterized_match_rule_tests {
    ($match_rule:expr, $($name:ident: $value:expr,)*) => {
        $(
            #[test]
            fn $name() {
                let (script, stdout, check_value) = $value;
                let system_shell = Bash{};
                let mut command = CrabCommand::new(
                            script.to_owned(),
                            Some(stdout.to_owned()),
                            None
                        );
                assert_eq!($match_rule(&mut command, Some(&system_shell)), check_value);
            }
        )*
    }
}

#[macro_export]
macro_rules! parameterized_get_new_command_tests {
    ($get_new_command:expr, $($name:ident: $value:expr,)*) => {
        $(
            #[test]
            fn $name() {
                let (script, stdout, expected) = $value;
                let system_shell = Bash{};
                let mut command = CrabCommand::new(
                            script.to_owned(),
                            Some(stdout.to_owned()),
                            None
                        );
                assert_eq!($get_new_command(&mut command, Some(&system_shell))[0], expected);
            }
        )*
    }
}

// FILE: ./src/rules/utils/npm.rs
use regex::Regex;
use std::process::Command;
use which::which;

pub fn is_npm_available() -> bool {
    which("npm").is_ok()
}

pub fn run_npm_command() -> Vec<u8> {
    let output = Command::new("npm")
        .arg("run-script")
        .output()
        .expect("Failed to execute command");
    output.stdout
}

pub fn mockable_get_scripts<F>(fn_run_npm_command: F) -> Vec<String>
where
    F: Fn() -> Vec<u8>,
{
    let npm_output = fn_run_npm_command();
    let stdout = String::from_utf8_lossy(&npm_output);
    let mut should_yield = false;
    let mut scripts = Vec::new();
    let re = Regex::new(r"^  \S+").unwrap();

    for line in stdout.lines() {
        if line.contains("available via `npm run-script`:") {
            should_yield = true;
            continue;
        }

        if should_yield && re.is_match(line) {
            let script = line.split_whitespace().next().unwrap().to_string();
            scripts.push(script);
        }
    }

    scripts
}
pub fn get_scripts() -> Vec<String> {
    mockable_get_scripts(run_npm_command)
}

#[cfg(test)]
mod tests {
    use crate::rules::utils::npm::mockable_get_scripts;

    #[test]
    fn test_get_scripts() {
        let run_script_stdout = b"
Lifecycle scripts included in code-view-web:
  test
    jest

available via `npm run-script`:
  build
    cp node_modules/ace-builds/src-min/ -a resources/ace/ && webpack --progress --colors -p --config ./webpack.production.config.js
  develop
    cp node_modules/ace-builds/src/ -a resources/ace/ && webpack-dev-server --progress --colors
  watch-test
    jest --verbose --watch

";
        let scripts = mockable_get_scripts(|| run_script_stdout.to_vec());
        assert_eq!(scripts, vec!["build", "develop", "watch-test"]);
    }
}

// FILE: ./src/rules/git_push.rs
use crate::{
    cli::command::CrabCommand,
    rules::utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
    rules::Rule,
    shell::Shell,
    utils::replace_argument,
};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script_parts.contains(&"push".to_owned())
            && stdout.contains("git push --set-upstream")
    } else {
        false
    }
}

fn get_upstream_option_index(command_parts: &[String]) -> Option<usize> {
    if command_parts.contains(&"--set-upstream".to_owned()) {
        command_parts.iter().position(|r| r == "--set-upstream")
    } else if command_parts.contains(&"-u".to_owned()) {
        command_parts.iter().position(|r| r == "-u")
    } else {
        None
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(stdout) = &command.output {
        // If --set-upstream or -u are passed, remove it and its argument. This is
        // because the remaining arguments are concatenated onto the command suggested
        // by git, which includes --set-upstream and its argument
        let mut command_parts = command.script_parts.clone();
        let upstream_option_index = get_upstream_option_index(&command_parts);

        if let Some(index) = upstream_option_index {
            command_parts.remove(index);
            if command_parts.len() > index {
                command_parts.remove(index);
            }
        } else {
            let push_idx = command_parts.iter().position(|r| r == "push").unwrap() + 1;
            while command_parts.len() > push_idx
                && !command_parts[command_parts.len() - 1].starts_with('-')
            {
                command_parts.pop();
            }
        }

        let re = Regex::new(r"git push (.*)").unwrap();
        let arguments = re.captures(stdout).unwrap()[1]
            .replace('\'', r"\'")
            .trim()
            .to_string();
        vec![replace_argument(
            &command_parts.join(" "),
            "push",
            &format!("push {arguments}"),
        )]
    } else {
        Vec::<String>::new()
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_push".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use crate::{parameterized_get_new_command_tests, parameterized_match_rule_tests};

    const OUTPUT_BITBUCKET: &str = "r#
Total 0 (delta 0), reused 0 (delta 0)
remote:
remote: Create pull request for feature/set-upstream:
remote:   https://bitbucket.org/set-upstream
remote:
To git@bitbucket.org:test.git
   e5e7fbb..700d998  feature/set-upstream -> feature/set-upstream
Branch feature/set-upstream set up to track remote branch feature/set-upstream from origin.
#";

    fn output_with_branch(branch_name: &str) -> String {
        if branch_name.is_empty() {
            "".to_string()
        } else {
            format!(
                "fatal: The current branch {branch_name} has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin {branch_name}

"
            )
        }
    }

    parameterized_match_rule_tests! {
        match_rule,
        match_rule_01: ("git push", output_with_branch("master"), true),
        match_rule_02: ("git push origin", output_with_branch("master"), true),
        unmatch_rule_01: ("git push origin", OUTPUT_BITBUCKET, false),
        unmatch_rule_02: ("git push master", output_with_branch(""), false),
        unmatch_rule_03: ("ls", output_with_branch("master"), false),
    }

    parameterized_get_new_command_tests! {
        get_new_command,
        get_new_command_1: ("git push", output_with_branch("master"), "git push --set-upstream origin master"),
        get_new_command_2: ("git push master", output_with_branch("master"), "git push --set-upstream origin master"),
        get_new_command_3: ("git push -u", output_with_branch("master"), "git push --set-upstream origin master"),
        get_new_command_4: ("git push -u origin", output_with_branch("master"), "git push --set-upstream origin master"),
        get_new_command_5: ("git push origin", output_with_branch("master"), "git push --set-upstream origin master"),
        get_new_command_6: ("git push --set-upstream origin", output_with_branch("master"), "git push --set-upstream origin master"),
        get_new_command_7: ("git push --quiet", output_with_branch("master"), "git push --set-upstream origin master --quiet"),
        get_new_command_8: ("git push --quiet origin", output_with_branch("master"), "git push --set-upstream origin master --quiet"),
        get_new_command_9: ("git -c test=test push --quiet origin", output_with_branch("master"), "git -c test=test push --set-upstream origin master --quiet"),
        get_new_command_10: ("git push", output_with_branch("test's"), "git push --set-upstream origin test\\'s"),
        get_new_command_11: ("git push --force", output_with_branch("master"), "git push --set-upstream origin master --force"),
        get_new_command_12: ("git push --force-with-lease", output_with_branch("master"), "git push --set-upstream origin master --force-with-lease"),
    }
}

// FILE: ./src/rules/git_bisect_usage.rs
use super::{utils::git::get_new_command_with_git_support, Rule};
use crate::utils::replace_command;
use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
};
use regex::Regex;

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("bisect") && stdout.contains("usage: git bisect")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(stdout) = &command.output {
        let re_broken = Regex::new(r"git bisect ([^ $]*).*").unwrap();
        let re_usage = Regex::new(r"usage: git bisect \[([^\]]+)\]").unwrap();

        let broken = re_broken.captures(&command.script);
        let usage = re_usage.captures(stdout);
        if let (Some(broken), Some(usage)) = (broken, usage) {
            replace_command(command, &broken[1], usage[1].split('|').collect())
        } else {
            Vec::<String>::new()
        }
    } else {
        Vec::<String>::new()
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_bisect_usage".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;

    const OUTPUT: &str = "usage: git bisect [help|start|bad|good|new|old|terms|skip|next|reset|visualize|replay|log|run]";

    use rstest::rstest;

    #[rstest]
    #[case("git bisect strt", OUTPUT, true)]
    #[case("git bisect rset", OUTPUT, true)]
    #[case("git bisect goood", OUTPUT, true)]
    #[case("git bisect", "", false)]
    #[case("git bisect start", "", false)]
    #[case("git bisect good", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git bisect goood", OUTPUT, vec!["good", "log", "old"])]
    #[case("git bisect strt", OUTPUT, vec!["start", "reset", "terms"])]
    #[case("git bisect rset", OUTPUT, vec!["reset", "terms", "start"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        let new_command = expected
            .iter()
            .map(|s| format!("git bisect {s}"))
            .collect::<Vec<_>>();
        assert_eq!(
            get_new_command(&mut command, Some(&system_shell)),
            new_command
        );
    }
}

// FILE: ./src/rules/git_pull_clone.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
    utils::replace_argument,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        output.contains("fatal: Not a git repository")
            && output.contains(
                "Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set).",
            )
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, _system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![replace_argument(&command.script, "pull", "clone")]
}

pub fn get_new_command(
    command: &mut CrabCommand,
    _system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, _system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_pull_clone".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const GIT_ERR: &str = "\
fatal: Not a git repository (or any parent up to mount point /home)\n\
Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set).\n";

    #[rstest]
    #[case("git pull git@github.com:mcarton/thefuck.git", GIT_ERR, true)]
    fn test_match(#[case] command: &str, #[case] output: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(output.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git pull git@github.com:mcarton/thefuck.git", GIT_ERR, vec!["git clone git@github.com:mcarton/thefuck.git"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] output: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(output.to_owned()), None);
        assert_eq!(
            get_new_command(&mut command, Some(&system_shell)),
            expected.iter().map(|&s| s.to_owned()).collect::<Vec<_>>()
        );
    }
}

// FILE: ./src/rules/ln_s_order.rs
use super::{get_new_command_without_sudo, match_rule_without_sudo, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use std::path::Path;

fn file_exists(path: &str) -> bool {
    Path::new(path).exists()
}

fn get_destination<F>(script_parts: &Vec<String>, fn_file_exists: F) -> Option<String>
where
    F: Fn(&str) -> bool,
{
    for part in script_parts {
        if part != "ln" && part != "-s" && part != "--symbolic" && fn_file_exists(part) {
            return Some(part.to_owned());
        }
    }
    None
}

fn auxiliary_match_rule<F>(command: &CrabCommand, fn_file_exists: F) -> bool
where
    F: Fn(&str) -> bool,
{
    if let Some(output) = &command.output {
        command.script_parts.first().is_some_and(|s| s == "ln")
            && (command.script_parts.contains(&"-s".to_owned())
                || command.script_parts.contains(&"--symbolic".to_owned()))
            && output.contains("File exists")
            && get_destination(&command.script_parts, fn_file_exists).is_some()
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(
        |command| auxiliary_match_rule(command, file_exists),
        command,
    )
}

pub fn auxiliary_get_new_command<F>(command: &CrabCommand, fn_file_exists: F) -> Vec<String>
where
    F: Fn(&str) -> bool,
{
    let destination = get_destination(&command.script_parts, fn_file_exists);
    if let Some(destination) = destination {
        let mut parts = command.script_parts.clone();
        parts.retain(|x| *x != destination);
        parts.push(destination);
        vec![parts.join(" ")]
    } else {
        vec![]
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(
        |command| auxiliary_get_new_command(command, file_exists),
        command,
    )
}

pub fn get_rule() -> Rule {
    Rule::new(
        "ln_s_order".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{auxiliary_get_new_command, auxiliary_match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const ERROR_FILE_EXISTS: &str = "ln: failed to create symbolic link 'source': File exists";

    #[rstest]
    #[case("ln -s dest source", ERROR_FILE_EXISTS, true, true)]
    #[case("ln dest -s source", ERROR_FILE_EXISTS, true, true)]
    #[case("ln dest source -s", ERROR_FILE_EXISTS, true, true)]
    #[case("ln dest source", ERROR_FILE_EXISTS, true, false)]
    #[case("ls -s dest source", ERROR_FILE_EXISTS, true, false)]
    #[case("ln -s dest source", "", true, false)]
    #[case("ln -s dest source", ERROR_FILE_EXISTS, false, false)]
    fn test_not_match(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] file_exists: bool,
        #[case] is_match: bool,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(auxiliary_match_rule(&command, |path| file_exists), is_match);
    }

    #[rstest]
    #[case("ln -s dest source", ERROR_FILE_EXISTS, vec!["ln -s source dest"])]
    #[case("ln dest -s source", ERROR_FILE_EXISTS, vec!["ln -s source dest"])]
    #[case("ln dest source -s", ERROR_FILE_EXISTS, vec!["ln source -s dest"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(auxiliary_get_new_command(&command, |path| true), expected);
    }
}

// FILE: ./src/rules/git_merge_unrelated.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command.script.contains("merge")
            && output.contains("fatal: refusing to merge unrelated histories")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![format!("{} --allow-unrelated-histories", command.script)]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_merge_unrelated".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const OUTPUT: &str = "fatal: refusing to merge unrelated histories";

    #[rstest]
    #[case("git merge test", OUTPUT, true)]
    #[case("git merge master", "", false)]
    #[case("ls", OUTPUT, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git merge local", OUTPUT, vec!["git merge local --allow-unrelated-histories"])]
    #[case("git merge -m \"test\" local", OUTPUT, vec!["git merge -m \"test\" local --allow-unrelated-histories"])]
    #[case("git merge -m \"test local\" local", OUTPUT, vec!["git merge -m \"test local\" local --allow-unrelated-histories"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/java.rs
use super::{get_new_command_without_sudo, match_rule_without_sudo, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    command.script.ends_with(".java")
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(auxiliary_match_rule, command)
}

pub fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    vec![command.script[..command.script.len() - 5].to_string()]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "java".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("java foo.java", "", true)]
    #[case("java bar.java", "", true)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("java foo.java", "", vec!["java foo"])]
    #[case("java bar.java", "", vec!["java bar"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_push_pull.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
    utils::replace_argument,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("push")
            && stdout.contains("! [rejected]")
            && stdout.contains("failed to push some refs to")
            && (stdout
                .contains("Updates were rejected because the tip of your current branch is behind")
                || stdout
                    .contains("Updates were rejected because the remote contains work that you do"))
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    let pull_command = command.script.replacen("push", "pull", 1);
    vec![system_shell.unwrap().and(vec![
        &replace_argument(&command.script, "push", "pull"),
        &command.script,
    ])]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_push_pull".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const GIT_ERR: &str = "\
To /tmp/foo\n\
 ! [rejected]        master -> master (non-fast-forward)\n\
 error: failed to push some refs to '/tmp/bar'\n\
 hint: Updates were rejected because the tip of your current branch is behind\n\
 hint: its remote counterpart. Integrate the remote changes (e.g.\n\
 hint: 'git pull ...') before pushing again.\n\
 hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n";

    const GIT_ERR2: &str = "\
To /tmp/foo\n\
 ! [rejected]        master -> master (non-fast-forward)\n\
 error: failed to push some refs to '/tmp/bar'\n\
hint: Updates were rejected because the remote contains work that you do\n\
hint: not have locally. This is usually caused by another repository pushing\n\
hint: to the same ref. You may want to first integrate the remote changes\n\
hint: (e.g., 'git pull ...') before pushing again.\n\
hint: See the 'Note about fast-forwards' in 'git push --help' for details.\n";

    const GIT_UPTODATE: &str = "Everything up-to-date";
    const GIT_OK: &str = "\
Counting objects: 3, done.\n\
Delta compression using up to 4 threads.\n\
Compressing objects: 100% (2/2), done.\n\
Writing objects: 100% (3/3), 282 bytes | 0 bytes/s, done.\n\
Total 3 (delta 0), reused 0 (delta 0)\n\
To /tmp/bar\n\
   514eed3..f269c79  master -> master\n";

    #[rstest]
    #[case("git push", GIT_ERR, true)]
    #[case("git push nvbn", GIT_ERR, true)]
    #[case("git push nvbn master", GIT_ERR, true)]
    #[case("git push", GIT_ERR2, true)]
    #[case("git push nvbn", GIT_ERR2, true)]
    #[case("git push nvbn master", GIT_ERR2, true)]
    #[case("git push", GIT_OK, false)]
    #[case("git push", GIT_UPTODATE, false)]
    #[case("git push nvbn", GIT_OK, false)]
    #[case("git push nvbn master", GIT_UPTODATE, false)]
    #[case("git push nvbn", GIT_OK, false)]
    #[case("git push nvbn master", GIT_UPTODATE, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git push", GIT_ERR, vec!["git pull && git push"])]
    #[case("git push nvbn", GIT_ERR, vec!["git pull nvbn && git push nvbn"])]
    #[case("git push nvbn master", GIT_ERR, vec!["git pull nvbn master && git push nvbn master"])]
    #[case("git push", GIT_ERR2, vec!["git pull && git push"])]
    #[case("git push nvbn", GIT_ERR2, vec!["git pull nvbn && git push nvbn"])]
    #[case("git push nvbn master", GIT_ERR2, vec!["git pull nvbn master && git push nvbn master"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/django_south_merge.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell};

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    command.script.contains("manage.py")
        && command.script.contains("migrate")
        && command
            .output
            .as_ref()
            .is_some_and(|output| output.contains("--merge: will just attempt the migration"))
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec![format!("{} --merge", command.script)]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "django_south_merge".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const OUTPUT: &str = r#"Running migrations for app:
 ! Migration app:0003_auto... should not have been applied before app:0002_auto__add_field_query_due_date_ but was.
Traceback (most recent call last):
  File "/home/nvbn/work/.../bin/python", line 42, in <module>
    exec(compile(__file__f.read(), __file__, "exec"))
  File "/home/nvbn/work/.../app/manage.py", line 34, in <module>
    execute_from_command_line(sys.argv)
  File "/home/nvbn/work/.../lib/django/core/management/__init__.py", line 443, in execute_from_command_line
    utility.execute()
  File "/home/nvbn/work/.../lib/django/core/management/__init__.py", line 382, in execute
    self.fetch_command(subcommand).run_from_argv(self.argv)
  File "/home/nvbn/work/.../lib/django/core/management/base.py", line 196, in run_from_argv
    self.execute(*args, **options.__dict__)
  File "/home/nvbn/work/.../lib/django/core/management/base.py", line 232, in execute
    output = self.handle(*args, **options)
  File "/home/nvbn/work/.../app/lib/south/management/commands/migrate.py", line 108, in handle
    ignore_ghosts = ignore_ghosts,
  File "/home/nvbn/work/.../app/lib/south/migration/__init__.py", line 207, in migrate_app
    raise exceptions.InconsistentMigrationHistory(problems)
south.exceptions.InconsistentMigrationHistory: Inconsistent migration history
The following options are available:
    --merge: will just attempt the migration ignoring any potential dependency conflicts.
"#;

    #[rstest]
    #[case("./manage.py migrate", OUTPUT, true)]
    #[case("python manage.py migrate", OUTPUT, true)]
    #[case("./manage.py migrate", "", false)]
    #[case("app migrate", OUTPUT, false)]
    #[case("./manage.py test", OUTPUT, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("./manage.py migrate auth", "", vec!["./manage.py migrate auth --merge"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_add_force.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
    utils::replace_argument,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        stdout.contains("Use -f if you really want to add them.")
            && command.script_parts.contains(&"add".to_owned())
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![replace_argument(&command.script, "add", "add --force")]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_add_force".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const OUTPUT: &str = "The following paths are ignored by one of your .gitignore files:\n\
dist/app.js\n\
dist/background.js\n\
dist/options.js\n\
Use -f if you really want to add them.\n";

    #[rstest]
    #[case("git add dist/*.js", OUTPUT, true)]
    #[case("git add dist/*.js", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git add dist/*.js", OUTPUT, vec!["git add --force dist/*.js"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_main_master.rs
use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
};

use super::{utils::git::get_new_command_with_git_support, Rule};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        stdout.contains("'master'") || stdout.contains("'main'")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(stdout) = &command.output {
        if stdout.contains("'master'") {
            vec![command.script.replace("master", "main")]
        } else {
            vec![command.script.replace("main", "master")]
        }
    } else {
        Vec::<String>::new()
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_main_master".to_owned(),
        None,
        Some(1200),
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    fn output_branch(branch_name: Option<&str>) -> String {
        if let Some(branch_name) = branch_name {
            format!("error: pathspec '{branch_name}' did not match any file(s) known to git")
        } else {
            "".to_owned()
        }
    }

    #[rstest]
    #[case("git checkout main", Some("main"), true)]
    #[case("git checkout master", Some("master"), true)]
    #[case("git show main", Some("main"), true)]
    #[case("git checkout master", None, false)]
    #[case("git checkout main", None, false)]
    #[case("git checkout wibble", Some("wibble"), false)]
    fn test_match(
        #[case] command: &str,
        #[case] branch_name: Option<&str>,
        #[case] is_match: bool,
    ) {
        let mut command =
            CrabCommand::new(command.to_owned(), Some(output_branch(branch_name)), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git checkout main", Some("main"), vec!["git checkout master"])]
    #[case("git checkout master", Some("master"), vec!["git checkout main"])]
    #[case("git checkout main", Some("main"), vec!["git checkout master"])]
    #[case("git checkout wibble", Some("wibble"),  vec!["git checkout wibble"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] branch_name: Option<&str>,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command =
            CrabCommand::new(command.to_owned(), Some(output_branch(branch_name)), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/no_such_file.rs
use super::{
    get_new_command_without_sudo, match_rule_without_sudo, utils::match_rule_with_is_app, Rule,
};
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

fn get_file(command_output: &str) -> Option<String> {
    let patterns = [
        r"mv: cannot move '[^']*' to '([^']*)': No such file or directory",
        r"mv: cannot move '[^']*' to '([^']*)': Not a directory",
        r"cp: cannot create regular file '([^']*)': No such file or directory",
        r"cp: cannot create regular file '([^']*)': Not a directory",
    ];
    for pattern in patterns.iter() {
        let re = Regex::new(pattern).unwrap();
        if let Some(caps) = re.captures(command_output) {
            return caps.get(1).map(|m| m.as_str().to_owned());
        }
    }
    None
}

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command
            .script_parts
            .first()
            .is_some_and(|s| s == "mv" || s == "cp")
            && get_file(output).is_some()
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(
        |command| match_rule_with_is_app(auxiliary_match_rule, command, vec!["mv", "cp"], None),
        command,
    )
}

pub fn auxiliary_get_new_command(command: &CrabCommand) -> Vec<String> {
    if let Some(output) = &command.output {
        let file = get_file(output);
        if let Some(file) = file {
            let dir = &file[0..file.rfind('/').unwrap_or(0)];
            vec![format!("mkdir -p {} && {}", dir, command.script)]
        } else {
            vec![]
        }
    } else {
        vec![]
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(auxiliary_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "no_such_file".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case(
        "mv foo bar/foo",
        "mv: cannot move 'foo' to 'bar/foo': No such file or directory",
        true
    )]
    #[case(
        "mv foo bar/",
        "mv: cannot move 'foo' to 'bar/': No such file or directory",
        true
    )]
    #[case(
        "cp foo bar/",
        "cp: cannot create regular file 'bar/': Not a directory",
        true
    )]
    #[case("mv foo bar/", "", false)]
    #[case("mv foo bar/foo", "mv: permission denied", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("mv foo bar/foo", "mv: cannot move 'foo' to 'bar/foo': No such file or directory", vec!["mkdir -p bar && mv foo bar/foo"])]
    #[case("mv foo bar/", "mv: cannot move 'foo' to 'bar/': No such file or directory", vec!["mkdir -p bar && mv foo bar/"])]
    #[case("cp foo bar/", "cp: cannot create regular file 'bar/': Not a directory", vec!["mkdir -p bar && cp foo bar/"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_remote_seturl_add.rs
use crate::{
    cli::command::CrabCommand,
    rules::utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
    rules::Rule,
    shell::Shell,
    utils::replace_argument,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("set-url") && stdout.contains("fatal: No such remote")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![replace_argument(&command.script, "set-url", "add")]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_remote_seturl_add".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("git remote set-url origin url", "fatal: No such remote", true)]
    #[case("git remote set-url origin url", "", false)]
    #[case("git remote add origin url", "", false)]
    #[case("git remote remove origin", "", false)]
    #[case("git remote prune origin", "", false)]
    #[case("git remote set-branches origin branch", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git remote set-url origin git@github.com:nvbn/thefuck.git", "", vec!["git remote add origin git@github.com:nvbn/thefuck.git"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/git_commit_amend.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    command.script_parts.contains(&"commit".to_owned())
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec!["git commit --amend".to_string()]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_commit_amend".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;

    use rstest::rstest;
    #[rstest]
    #[case("git commit -m \"test\"", "test output", true)]
    #[case("git commit", "", true)]
    #[case("git branch foo", "", false)]
    #[case("git checkout feature/test_commit", "", false)]
    #[case("git push", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git commit -m \"test commit\"")]
    #[case("git commit")]
    fn test_get_new_command(#[case] command: &str) {
        let mut command = CrabCommand::new(command.to_owned(), None, None);
        assert_eq!(
            get_new_command(&mut command, None),
            vec!["git commit --amend"]
        );
    }
}

// FILE: ./src/rules/long_form_help.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell};
use regex::Regex;

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(output) = &command.output {
        let re =
            Regex::new(r"(?:Run|Try) '([^']+)'(?: or '[^']+')? for (?:details|more information).")
                .unwrap();
        re.is_match(output) || output.contains("--help")
    } else {
        false
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(output) = &command.output {
        let re =
            Regex::new(r"(?:Run|Try) '([^']+)'(?: or '[^']+')? for (?:details|more information).")
                .unwrap();
        if let Some(caps) = re.captures(output) {
            vec![caps.get(1).map_or("", |m| m.as_str()).to_owned()]
        } else {
            vec![command.script.replace("-h", "--help")]
        }
    } else {
        Vec::<String>::new()
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "long_form_help".to_owned(),
        None,
        Some(5000),
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("grep -h", "Try 'grep --help' for more information.", true)]
    #[case("", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("grep -h", "", vec!["grep --help"])]
    #[case("tar -h", "", vec!["tar --help"])]
    #[case("docker run -h", "", vec!["docker run --help"])]
    #[case("cut -h", "", vec!["cut --help"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/cargo.rs
use crate::{cli::command::CrabCommand, shell::Shell};

use super::Rule;

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    command.script == "cargo"
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    vec!["cargo build".to_owned()]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "cargo".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use crate::{cli::command::CrabCommand, rules::cargo::match_rule};

    #[test]
    fn test_match_rule() {
        assert!(match_rule(
            &mut CrabCommand::new("cargo".to_owned(), Some("multiple\nlines".to_owned()), None),
            None
        ));
        assert!(!match_rule(
            &mut CrabCommand::new(
                "acargo".to_owned(),
                Some("multiple\nlines".to_owned()),
                None
            ),
            None
        ));
    }
}

// FILE: ./src/rules/brew_link.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        (command
            .script_parts
            .get(1)
            .is_some_and(|s| s == "ln" || s == "link"))
            && output.contains("brew link --overwrite --dry-run")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["brew"], Some(2))
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let mut command_parts = command.script_parts.clone();
    "link".clone_into(&mut command_parts[1]);
    command_parts.insert(2, "--overwrite".to_owned());
    command_parts.insert(3, "--dry-run".to_owned());
    vec![command_parts.join(" ")]
}

pub fn get_rule() -> Rule {
    Rule::new(
        "brew_link".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const OUTPUT: &str = "Error: Could not symlink bin/gcp\nTarget /usr/local/bin/gcp\nalready exists. You may want to remove it:\n  rm '/usr/local/bin/gcp'\n\nTo force the link and overwrite all conflicting files:\n  brew link --overwrite coreutils\n\nTo list all files that would be deleted:\n  brew link --overwrite --dry-run coreutils\n";

    #[rstest]
    #[case("brew link coreutils", OUTPUT, true)]
    #[case("brew ln coreutils", OUTPUT, true)]
    #[case("brew link coreutils", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("brew link coreutils", OUTPUT, vec!["brew link --overwrite --dry-run coreutils"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/git_rm_recursive.rs
use crate::{
    cli::command::CrabCommand,
    rules::{
        utils::git::{get_new_command_with_git_support, match_rule_with_git_support},
        Rule,
    },
    shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains(" rm ")
            && stdout.contains("fatal: not removing '")
            && stdout.contains("' recursively without -r")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    let mut command_parts = command.script_parts.clone();
    if let Some(index) = command_parts.iter().position(|r| r == "rm") {
        command_parts.insert(index + 1, "-r".to_string());
    }
    vec![command_parts.join(" ")]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_rm_recursive".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("git rm fo", "fatal: not removing 'foo' recursively without -r", true)]
    #[case(
        "git rm foo bar",
        "fatal: not removing 'foo bar' recursively without -r",
        true
    )]
    #[case("git rm foo", "", false)]
    #[case("git rm foo bar", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git rm foo", "fatal: not removing 'foo' recursively without -r", vec!["git rm -r foo"])]
    #[case("git rm foo bar", "fatal: not removing 'foo bar' recursively without -r", vec!["git rm -r foo bar"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/pip_install.rs
use super::{match_rule_without_sudo, utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        command.script.contains("pip install") && output.contains("Permission denied")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(
        |command| match_rule_with_is_app(auxiliary_match_rule, command, vec!["pip"], None),
        command,
    )
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if !command.script.contains("--user") {
        vec![command.script.replace(" install ", " install --user ")]
    } else {
        vec![format!("sudo {}", command.script.replace(" --user", ""))]
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "pip_install".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    const ERROR_PERMISSION_DENIED: &str = "\nCould not install packages due to an EnvironmentError: [Errno 13] Permission denied: '/Library/Python/2.7/site-packages/entrypoints.pyc'\nConsider using the `--user` option or check the permissions.\n";
    const SUCCESS_INSTALL: &str = "\nCollecting bacon\n  Downloading https://files.pythonhosted.org/packages/b2/81/19fb79139ee71c8bc4e5a444546f318e2b87253b8939ec8a7e10d63b7341/bacon-0.3.1.zip (11.0MB)\n    100% |████████████████████████████████| 11.0MB 3.0MB/s\nInstalling collected packages: bacon\n  Running setup.py install for bacon ... done\nSuccessfully installed bacon-0.3.1\n";

    #[rstest]
    #[case("pip install -r requirements.txt", ERROR_PERMISSION_DENIED, true)]
    #[case("pip install bacon", SUCCESS_INSTALL, false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("pip install -r requirements.txt", "", vec!["pip install --user -r requirements.txt"])]
    #[case("pip install bacon", "", vec!["pip install --user bacon"])]
    #[case("pip install --user -r requirements.txt", "", vec!["sudo pip install -r requirements.txt"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/tmux.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell, utils::replace_command};
use regex::Regex;

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(output) = &command.output {
        if output.contains("ambiguous command:") && output.contains("could be:") {
            return true;
        }
        return false;
    }
    false
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let re = Regex::new(r"ambiguous command: (.*), could be: (.*)").unwrap();
    if let Some(stdout) = &command.output {
        let caps = re.captures(stdout).unwrap();

        let old_cmd = caps.get(1).unwrap().as_str();
        let suggestions: Vec<&str> = caps
            .get(2)
            .unwrap()
            .as_str()
            .split(',')
            .map(|s| s.trim())
            .collect();

        replace_command(command, old_cmd, suggestions)
    } else {
        Vec::<String>::new()
    }
}
pub fn get_rule() -> Rule {
    Rule::new(
        "tmux".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use crate::cli::command::CrabCommand;

    use super::{get_new_command, match_rule};

    const TMUX_AMBIGUOUS: &str = "ambiguous command: list, could be: list-buffers, list-clients, list-commands, list-keys, list-panes, list-sessions, list-windows";

    #[test]
    fn test_get_new_command() {
        let command = CrabCommand::new(
            "tmux list".to_owned(),
            Some(TMUX_AMBIGUOUS.to_owned()),
            None,
        );
        assert_eq!(
            get_new_command(&mut CrabCommand::new("tmux list".to_owned(), Some("ambiguous command: list, could be: list-buffers, list-clients, list-commands, list-keys, list-panes, list-sessions, list-windows".to_owned()), None), None),
            vec!["tmux list-keys", "tmux list-panes", "tmux list-buffers"]
        );
    }

    #[test]
    fn test_match() {
        let mut command = CrabCommand::new(
            "tmux list".to_owned(),
            Some(TMUX_AMBIGUOUS.to_owned()),
            None,
        );
        match_rule(&mut command, None);
    }
}

// FILE: ./src/rules/git_branch_delete_checked_out.rs
use super::{utils::git::get_new_command_with_git_support, Rule};
use crate::utils::replace_argument;
use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        (command.script.contains("branch -d") || command.script.contains("branch -D"))
            && stdout.contains("error: Cannot delete branch '")
            && stdout.contains("' checked out at '")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    vec![system_shell.unwrap().and(vec![
        "git checkout master",
        &replace_argument(&command.script, "-d", "-D"),
    ])]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_branch_delete_checked_out".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;

    const OUTPUT: &str = "error: Cannot delete branch 'foo' checked out at '/bar/foo'";

    use rstest::rstest;

    #[rstest]
    #[case("git branch -d foo", OUTPUT, true)]
    #[case("git branch -D foo", OUTPUT, true)]
    #[case("git branch -d foo", "Deleted branch foo (was a1b2c3d).", false)]
    #[case("git branch -D foo", "Deleted branch foo (was a1b2c3d).", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git branch -d foo", OUTPUT, vec!["git checkout master && git branch -D foo"])]
    #[case("git branch -D foo", OUTPUT, vec!["git checkout master && git branch -D foo"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, Some(&system_shell)), expected);
    }
}

// FILE: ./src/rules/git_help_aliased.rs
use super::{utils::git::get_new_command_with_git_support, Rule};

use crate::{
    cli::command::CrabCommand, rules::utils::git::match_rule_with_git_support, shell::Shell,
};

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(stdout) = &command.output {
        command.script.contains("help") && stdout.contains(" is aliased to ")
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_git_support(auxiliary_match_rule, command)
}

fn auxiliary_get_new_command(
    command: &CrabCommand,
    system_shell: Option<&dyn Shell>,
) -> Vec<String> {
    if let Some(stdout) = &command.output {
        let aliased = stdout.splitn(3, '`').collect::<Vec<_>>();
        if aliased.len() > 2 {
            let aliased = aliased[2].splitn(2, '\'').collect::<Vec<_>>()[0]
                .splitn(2, ' ')
                .collect::<Vec<_>>()[0];
            vec![format!("git help {}", aliased)]
        } else {
            Vec::<String>::new()
        }
    } else {
        Vec::<String>::new()
    }
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_with_git_support(auxiliary_get_new_command, command, system_shell)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "git_help_aliased".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;

    use rstest::rstest;
    #[rstest]
    #[case("git help st", "`git st' is aliased to `status'", true)]
    #[case("git help ds", "`git ds' is aliased to `diff --staged'", true)]
    #[case("git help status", "GIT-STATUS(1)...Git Manual...GIT-STATUS(1)", false)]
    #[case("git help diff", "GIT-DIFF(1)...Git Manual...GIT-DIFF(1)", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("git help st", "`git st' is aliased to `status'", "git help status")]
    #[case(
        "git help ds",
        "`git ds' is aliased to `diff --staged'",
        "git help diff"
    )]
    fn test_get_new_command(#[case] command: &str, #[case] stdout: &str, #[case] expected: &str) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), vec![expected]);
    }
}

// FILE: ./src/rules/sudo.rs
use super::Rule;
use crate::{cli::command::CrabCommand, shell::Shell};

const PATTERNS: [&str; 28] = [
    "permission denied",
    "eacces",
    "pkg: insufficient privileges",
    "you cannot perform this operation unless you are root",
    "non-root users cannot",
    "operation not permitted",
    "not super-user",
    "superuser privilege",
    "root privilege",
    "this command has to be run under the root user.",
    "this operation requires root.",
    "requested operation requires superuser privilege",
    "must be run as root",
    "must run as root",
    "must be superuser",
    "must be root",
    "need to be root",
    "need root",
    "needs to be run as root",
    "only root can ",
    "you don't have access to the history db.",
    "authentication is required",
    "edspermissionerror",
    "you don't have write permissions",
    "use `sudo`",
    "sudorequirederror",
    "error: insufficient privileges",
    "updatedb: can not open a temporary file",
];

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    if let Some(output) = &command.output {
        if !command.script_parts.is_empty()
            && !command.script_parts.contains(&"&&".to_owned())
            && command.script_parts[0] == "sudo"
        {
            return false;
        }
        for pattern in PATTERNS {
            if output.to_lowercase().contains(pattern) {
                return true;
            }
        }
    }
    false
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if command.script.contains("&&") {
        vec![format!(
            "sudo sh -c \"{}\"",
            command
                .script_parts
                .iter()
                .filter(|s| s != &"sudo")
                .map(|s| s.to_string())
                .collect::<Vec<_>>()
                .join(" ")
        )]
    } else if command.script.contains('>') {
        vec![format!(
            "sudo sh -c \"{}\"",
            command.script.replace('"', "\\\"")
        )]
    } else {
        vec![format!("sudo {}", command.script)]
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "sudo".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("", "Permission denied", true)]
    #[case("", "permission denied", true)]
    #[case("", "npm ERR! Error: EACCES, unlink", true)]
    #[case("", "requested operation requires superuser privilege", true)]
    #[case("", "need to be root", true)]
    #[case("", "need root", true)]
    #[case("", "shutdown: NOT super-user", true)]
    #[case("", "Error: This command has to be run with superuser privileges (under the root user on most systems).", true)]
    #[case(
        "",
        "updatedb: can not open a temporary file for `/var/lib/mlocate/mlocate.db",
        true
    )]
    #[case("", "must be root", true)]
    #[case("", "You don't have access to the history DB.", true)]
    #[case(
        "",
        "error: [Errno 13] Permission denied: '/usr/local/lib/python2.7/dist-packages/ipaddr.py'",
        true
    )]
    #[case("", "", false)]
    #[case("sudo ls", "Permission denied", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("ls", "Permission denied", vec!["sudo ls"])]
    #[case("echo a > b", "Permission denied", vec!["sudo sh -c \"echo a > b\""])]
    #[case("echo \"a\" >> b", "Permission denied", vec!["sudo sh -c \"echo \\\"a\\\" >> b\""])]
    #[case("mkdir && touch a", "Permission denied", vec!["sudo sh -c \"mkdir && touch a\""])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/mvn_unknown_lifecycle_phase.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{
    cli::command::CrabCommand,
    shell::Shell,
    utils::{get_close_matches, replace_command},
};
use regex::Regex;

fn get_failed_lifecycle(command_output: &str) -> Option<String> {
    let re = Regex::new(r#"\[ERROR\] Unknown lifecycle phase \"(.+)\""#).unwrap();
    re.captures(command_output).map(|caps| caps[1].to_string())
}

fn get_available_lifecycles(command_output: &str) -> Option<String> {
    let re = Regex::new(r"Available lifecycle phases are: (.+) -> \[Help 1\]").unwrap();
    re.captures(command_output).map(|caps| caps[1].to_string())
}

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    if let Some(output) = &command.output {
        get_failed_lifecycle(output).is_some() && get_available_lifecycles(output).is_some()
    } else {
        false
    }
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["mvn"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if let Some(output) = &command.output {
        let failed_lifecycle = get_failed_lifecycle(output);
        let available_lifecycles = get_available_lifecycles(output);
        if let (Some(failed_lifecycle), Some(available_lifecycles)) =
            (failed_lifecycle, available_lifecycles)
        {
            let available_lifecycles: Vec<&str> = available_lifecycles.split(", ").collect();
            let selected_lifecycle =
                get_close_matches(&failed_lifecycle, &available_lifecycles, None, None);
            replace_command(command, &failed_lifecycle, selected_lifecycle)
        } else {
            vec![]
        }
    } else {
        vec![]
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "mvn_unknown_lifecycle_phase".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    const ERROR_UNKNOWN_LIFECYCLE: &str = "[ERROR] Unknown lifecycle phase \"cle\". You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]";
    const MVN_CLEAN: &str = "\n[INFO] Scanning for projects...[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building test 0.2
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ test ---
[INFO] Deleting /home/mlk/code/test/target
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.477s
[INFO] Finished at: Wed Aug 26 13:05:47 BST 2015
[INFO] Final Memory: 6M/240M
[INFO] ------------------------------------------------------------------------";

    #[rstest]
    #[case("mvn cle", ERROR_UNKNOWN_LIFECYCLE, true)]
    #[case("mvn clean", MVN_CLEAN, false)]
    #[case("mvn --help", "", false)]
    #[case("mvn -v", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }
    #[rstest]
    #[case("mvn cle", r#"[ERROR] Unknown lifecycle phase "cle". You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]"#, vec!["mvn clean", "mvn compile"])]
    #[case("mvn claen package", r#"[ERROR] Unknown lifecycle phase "claen". You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -> [Help 1]"#, vec!["mvn clean package", "mvn pre-clean package", "mvn post-clean package"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/cd_correction.rs
use crate::rules::cd_mkdir::auxiliary_get_new_command;
use crate::utils::get_close_matches;
use crate::{cli::command::CrabCommand, shell::Shell};

use std::env;
use std::fs;
use std::path::{Path, MAIN_SEPARATOR};

use super::{get_new_command_without_sudo, match_rule_without_sudo, Rule};

fn get_sub_dirs(parent: &str) -> Vec<String> {
    let mut sub_dirs = Vec::new();
    if let Ok(entries) = fs::read_dir(parent) {
        let sub_dirs: Vec<String> = entries
            .into_iter()
            .flatten()
            .filter(|entry| entry.metadata().is_ok_and(|m| m.is_dir()))
            .map(|entry| entry.path().to_str().unwrap().to_string())
            .collect();
    }
    sub_dirs
}
fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    command.script.starts_with("cd ")
        && (if let Some(output) = &command.output {
            output.to_lowercase().contains("no such file or directory")
                || output.to_lowercase().contains("cd: can\"t cd to")
                || output.to_lowercase().contains("does not exist")
        } else {
            false
        })
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_without_sudo(auxiliary_match_rule, command)
}

fn _get_new_command(command: &CrabCommand) -> Vec<String> {
    if command.script_parts.len() > 1 {
        let mut dest: Vec<&str> = command.script_parts[1].split(MAIN_SEPARATOR).collect();
        let mut cwd;
        if dest.last() == Some(&"") {
            dest.pop();
        }
        if dest[0].is_empty() {
            cwd = MAIN_SEPARATOR.to_string();
            dest.remove(0);
        } else {
            cwd = env::current_dir().unwrap().to_str().unwrap().to_string();
        }

        for directory in dest {
            if directory == "." {
                continue;
            } else if directory == ".." {
                cwd = Path::new(&cwd)
                    .parent()
                    .unwrap()
                    .to_str()
                    .unwrap()
                    .to_string();
                continue;
            }
            let sub_dirs = get_sub_dirs(&cwd);
            let sub_dirs = sub_dirs.iter().map(|s| s.as_str()).collect::<Vec<&str>>();
            let best_matches = get_close_matches(directory, &sub_dirs, None, None);
            if !best_matches.is_empty() {
                cwd = Path::new(&cwd)
                    .join(best_matches[0])
                    .to_str()
                    .unwrap()
                    .to_string();
            } else {
                return auxiliary_get_new_command(command);
            }
        }
        return vec![format!("cd \"{}\"", cwd)];
    }
    vec![]
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    get_new_command_without_sudo(_get_new_command, command)
}

pub fn get_rule() -> Rule {
    Rule::new(
        "cd_correction".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::auxiliary_match_rule;
    use crate::cli::command::CrabCommand;
    use rstest::rstest;

    #[rstest]
    #[case("cd foo", "cd: foo: No such file or directory\n", true)]
    #[case("cd foo/bar/baz", "cd: foo: No such file or directory", true)]
    #[case("cd foo/bar/baz", "cd: can\"t cd to foo/bar/baz", true)]
    #[case("cd /foo/bar/", "cd: The directory \"/foo/bar/\" does not exist", true)]
    #[case("cd foo", "", false)]
    #[case("", "", false)]
    fn test_match(#[case] command: &str, #[case] stderr: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), None, Some(stderr.to_owned()));
        assert_eq!(auxiliary_match_rule(&command), is_match);
    }
}

// FILE: ./src/rules/man.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(|command| true, command, vec!["man"], Some(1))
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    if command.script.contains('3') {
        return vec![command.script.replace('3', "2")];
    }
    if command.script.contains('2') {
        return vec![command.script.replace('2', "3")];
    }
    if let Some(output) = &command.output {
        let last_arg = command.script_parts.last().unwrap();
        let help_command = format!("{last_arg} --help");

        if output.trim() == format!("No manual entry for {last_arg}") {
            return vec![help_command];
        }

        let mut split_cmd2 = command.script_parts.clone();
        let mut split_cmd3 = split_cmd2.clone();

        split_cmd2.insert(1, " 2 ".to_string());
        split_cmd3.insert(1, " 3 ".to_string());

        vec![split_cmd3.join(""), split_cmd2.join(""), help_command]
    } else {
        Vec::<String>::new()
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "man".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        None,
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use rstest::rstest;

    #[rstest]
    #[case("man read", "", true)]
    #[case("man 2 read", "", true)]
    #[case("man 3 read", "", true)]
    #[case("man -s2 read", "", true)]
    #[case("man -s3 read", "", true)]
    #[case("man -s 2 read", "", true)]
    #[case("man -s 3 read", "", true)]
    #[case("man", "", false)]
    #[case("man ", "", false)]
    fn test_match(#[case] command: &str, #[case] stdout: &str, #[case] is_match: bool) {
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(match_rule(&mut command, None), is_match);
    }

    #[rstest]
    #[case("man read", "", vec!["man 3 read", "man 2 read", "read --help"])]
    #[case("man missing", "No manual entry for missing\n", vec!["missing --help"])]
    #[case("man 2 read", "", vec!["man 3 read"])]
    #[case("man 3 read", "", vec!["man 2 read"])]
    #[case("man -s2 read", "", vec!["man -s3 read"])]
    #[case("man -s3 read", "", vec!["man -s2 read"])]
    #[case("man -s 2 read", "", vec!["man -s 3 read"])]
    #[case("man -s 3 read", "", vec!["man -s 2 read"])]
    fn test_get_new_command(
        #[case] command: &str,
        #[case] stdout: &str,
        #[case] expected: Vec<&str>,
    ) {
        let system_shell = Bash {};
        let mut command = CrabCommand::new(command.to_owned(), Some(stdout.to_owned()), None);
        assert_eq!(get_new_command(&mut command, None), expected);
    }
}

// FILE: ./src/rules/dirty_untar.rs
use super::{utils::match_rule_with_is_app, Rule};
use crate::{cli::command::CrabCommand, shell::Shell};
use shlex::Quoter;
use std::fs;
use tar::Archive;

const TAR_EXTENSIONS: [&str; 15] = [
    ".tar",
    ".tar.Z",
    ".tar.bz2",
    ".tar.gz",
    ".tar.lz",
    ".tar.lzma",
    ".tar.xz",
    ".taz",
    ".tb2",
    ".tbz",
    ".tbz2",
    ".tgz",
    ".tlz",
    ".txz",
    ".tz",
];

fn is_tar_extract(cmd: &str) -> bool {
    if cmd.contains("--extract") {
        return true;
    }
    let cmd_split: Vec<&str> = cmd.split_whitespace().collect();
    cmd_split.len() > 1 && cmd_split[1].contains('x')
}

fn tar_file(cmd: &[String]) -> Option<(String, String)> {
    for c in cmd {
        for ext in &TAR_EXTENSIONS {
            if c.ends_with(ext) {
                return Some((c.clone(), c[..c.len() - ext.len()].to_string()));
            }
        }
    }
    None
}

fn auxiliary_match_rule(command: &CrabCommand) -> bool {
    !command.script.contains("-C")
        && is_tar_extract(&command.script)
        && tar_file(&command.script_parts).is_some()
}

pub fn match_rule(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> bool {
    match_rule_with_is_app(auxiliary_match_rule, command, vec!["tar"], None)
}

pub fn get_new_command(command: &mut CrabCommand, system_shell: Option<&dyn Shell>) -> Vec<String> {
    let shlex_quoter = Quoter::new();
    match tar_file(&command.script_parts) {
        Some((_, filepath_no_ext)) => {
            let dir = shlex_quoter.quote(&filepath_no_ext).unwrap();
            vec![system_shell.unwrap().and(vec![
                &format!("mkdir -p {dir}"),
                &format!("{cmd} -C {dir}", dir = dir, cmd = command.script),
            ])]
        }
        nonw => vec![],
    }
}

pub fn side_effect(old_cmd: CrabCommand, command: Option<&str>) {
    if let Some((filepath, _)) = tar_file(&old_cmd.script_parts) {
        let mut archive = Archive::new(std::fs::File::open(filepath).unwrap());

        for file in archive.entries().unwrap() {
            let file = file.unwrap();
            let path = file.path().unwrap().to_path_buf();

            let filename = path.to_string_lossy();
            if !filename.starts_with("._") {
                if !path
                    .canonicalize()
                    .unwrap()
                    .starts_with(std::env::current_dir().unwrap())
                {
                    // it's unsafe to overwrite files outside of the current directory
                    continue;
                }

                if path.is_file() {
                    fs::remove_file(path).unwrap_or(());
                }
            }
        }
    }
}

pub fn get_rule() -> Rule {
    Rule::new(
        "tar".to_owned(),
        None,
        None,
        None,
        match_rule,
        get_new_command,
        Some(side_effect),
    )
}

#[cfg(test)]
mod tests {
    use super::{get_new_command, match_rule, side_effect, TAR_EXTENSIONS};
    use crate::cli::command::CrabCommand;
    use crate::shell::Bash;
    use std::env;
    use std::fs;
    use std::fs::File;
    use std::io::Write;
    use std::path::Path;
    use std::path::PathBuf;
    use tar::Archive;
    use tar::Builder;
    use tempfile::TempDir;

    pub fn tar_error(filename: &str, tmp_dir: &TempDir) {
        let filename = format!("./{}", filename);
        let path = tmp_dir.path().join(&filename);

        let _ = env::set_current_dir(tmp_dir.path());
        reset(&path);

        let entries = fs::read_dir(".").unwrap();
        let mut files = entries
            .map(|res| res.map(|e| e.path()))
            .collect::<Result<Vec<_>, std::io::Error>>()
            .unwrap();
        let mut expected_files = vec![
            Path::new(&filename),
            Path::new("./a"),
            Path::new("./b"),
            Path::new("./c"),
            Path::new("./d"),
        ];
        expected_files.sort();
        files.sort();
        assert_eq!(files, expected_files);

        let entries = fs::read_dir("./d").unwrap();
        let mut files = entries
            .map(|res| res.map(|e| e.path()))
            .collect::<Result<Vec<_>, std::io::Error>>()
            .unwrap();
        files.sort();
        assert_eq!(files, vec![Path::new("./d/e")]);
    }

    fn reset(path: &Path) {
        fs::create_dir("d").unwrap();
        let files = vec!["a", "b", "c", "d/e"];

        let tar_gz = File::create(path).unwrap();
        let mut tar = Builder::new(tar_gz);

        for file in files {
            let file_path = PathBuf::from(file);

            let mut f = File::create(&file_path).unwrap();
            f.write_all(b"*").unwrap();
            tar.append_path(&file_path).unwrap();
            fs::remove_file(&file_path).unwrap();
        }

        let tar_gz = File::open(path).unwrap();
        let mut tar = Archive::new(tar_gz);
        tar.unpack(".").unwrap();
    }

    fn get_filename() -> Vec<(
        Box<dyn Fn(&str) -> String>,
        Box<dyn Fn(&str) -> String>,
        Box<dyn Fn(&str) -> String>,
    )> {
        vec![
            (
                Box::new(|s: &str| format!("foo{}", s)),
                Box::new(|s: &str| format!("foo{}", s)),
                Box::new(|s: &str| format!("foo{}", s)),
            ),
            (
                Box::new(|s: &str| format!(r#""foo bar{}""#, s)),
                Box::new(|s: &str| format!("foo bar{}", s)),
                Box::new(|s: &str| format!("'foo bar{}'", s)),
            ),
        ]
    }

    fn get_script() -> Vec<(
        Box<dyn Fn(&str) -> String>,
        Box<dyn Fn(&str, &str) -> String>,
    )> {
        vec![
            (
                Box::new(|s: &str| format!("tar xvf {}", s)),
                Box::new(|dir: &str, filename: &str| {
                    format!(
                        "mkdir -p {dir} && tar xvf {filename} -C {dir}",
                        dir = dir,
                        filename = filename
                    )
                }),
            ),
            (
                Box::new(|s: &str| format!("tar -xvf {}", s)),
                Box::new(|dir: &str, filename: &str| {
                    format!(
                        "mkdir -p {dir} && tar -xvf {filename} -C {dir}",
                        dir = dir,
                        filename = filename
                    )
                }),
            ),
            (
                Box::new(|s: &str| format!("tar --extract -f {}", s)),
                Box::new(|dir: &str, filename: &str| {
                    format!(
                        "mkdir -p {dir} && tar --extract -f {filename} -C {dir}",
                        dir = dir,
                        filename = filename
                    )
                }),
            ),
        ]
    }

    #[test]
    // The unit tests were split into test_match, test_side_effect and test_get_new_command.
    // However, there was an issue with tempfile raising errors when the tests were running in
    // parallel. Hence, we moved them to the same function.
    fn test_dirty_unrar() {
        for (filename, unquoted, quoted) in get_filename() {
            for (script, fixed) in get_script() {
                for ext in TAR_EXTENSIONS {
                    let tmp_dir = TempDir::new().unwrap();
                    tar_error(&unquoted(ext), &tmp_dir);
                    let mut command =
                        CrabCommand::new(script(&filename(ext)), Some("".to_owned()), None);
                    assert!(match_rule(&mut command, None));

                    side_effect(command, None);
                    let entries = fs::read_dir(".").unwrap();
                    let mut files = entries
                        .map(|res| res.map(|e| e.path()))
                        .collect::<Result<Vec<_>, std::io::Error>>()
                        .unwrap();
                    let unquoted = format!("./{}", unquoted(ext));
                    let mut expected_files = vec![Path::new(&unquoted), Path::new("./d")];
                    files.sort();
                    expected_files.sort();
                    assert_eq!(files, expected_files);

                    let system_shell = Bash {};
                    let mut command =
                        CrabCommand::new(script(&filename(ext)), Some("".to_owned()), None);
                    assert_eq!(
                        get_new_command(&mut command, Some(&system_shell)),
                        vec![fixed(&quoted(""), &filename(ext))]
                    );
                }
            }
        }
    }
}

// FILE: ./src/cli/parser.rs
// FILE: ./src/cli/parser.rs
use clap::{command, Arg, ArgAction};
use std::env;

use crate::{ARGUMENT_PLACEHOLDER, ENV_VAR_NAME_ALIAS, ENV_VAR_NAME_HISTORY, ENV_VAR_NAME_SHELL};

/// Prepares arguments by:
/// - Removing placeholder and moving arguments after it to beginning, we need this
///   to distinguish arguments from `command` with ours;
/// - Adding `--` before `command`, so that our parser ignores arguments of `command`.
///
/// * `argv`:
pub fn prepare_arguments(mut argv: Vec<String>) -> Vec<String> {
    if let Some(index) = argv.iter().position(|x| *x == ARGUMENT_PLACEHOLDER) {
        let mut command_part = argv.split_off(index);
        // Remove the placeholder itself
        command_part.remove(0);

        let mut processed_args = command_part;
        processed_args.push("--".to_owned());
        processed_args.append(&mut argv);
        processed_args
    } else {
        if !argv.is_empty() && !argv[0].starts_with('-') && argv[0] != "--" {
            argv.insert(0, "--".to_owned());
        }
        argv
    }
}

/// Generate an argument parser using clap
pub fn get_parser() -> clap::Command {
    command!()
        .no_binary_name(true)
        .arg(
            Arg::new("alias")
                .long("alias")
                .short('a')
                .help("Prints the shell function using the given alias")
                .required(false)
                .env(ENV_VAR_NAME_ALIAS)
                .default_value("crab"),
        )
        .arg(
            Arg::new("shell")
                .long("shell")
                .short('s')
                .help("Shell used to call ohcrab")
                .env(ENV_VAR_NAME_SHELL)
                .required(false)
                .default_value("bash"),
        )
        .arg(
            Arg::new("debug")
                .long("debug")
                .short('d')
                .help("Enable debug output")
                .action(ArgAction::SetTrue)
                .required(false),
        )
        .arg(
            Arg::new("select-first")
                .long("select-first")
                .short('y')
                .help("Automatically select the first corrected command")
                .action(ArgAction::SetTrue)
                .required(false),
        )
        .arg(
            Arg::new("command")
                .help("Command that should be fixed")
                .action(ArgAction::Append)
                .required(false)
                .env(ENV_VAR_NAME_HISTORY)
                .last(true),
        )
}

#[cfg(test)]
mod tests {
    use crate::{
        cli::parser::{get_parser, prepare_arguments},
        ARGUMENT_PLACEHOLDER, ENV_VAR_NAME_ALIAS, ENV_VAR_NAME_HISTORY, ENV_VAR_NAME_SHELL,
    };
    use clap::parser::ValueSource;
    use std::env;

    // This single test now covers all logic related to the 'alias' argument,
    // preventing race conditions.
    #[test]
    fn test_parser_alias_logic() {
        // Test default value
        env::remove_var(ENV_VAR_NAME_ALIAS);
        let matches = get_parser().get_matches_from(Vec::<String>::new());
        assert_eq!(
            matches.value_source("alias"),
            Some(ValueSource::DefaultValue)
        );
        assert_eq!(
            matches.get_one::<String>("alias"),
            Some(&"crab".to_string())
        );

        // Test value from environment variable
        env::set_var(ENV_VAR_NAME_ALIAS, "env_alias");
        let matches = get_parser().get_matches_from(Vec::<String>::new());
        assert_eq!(
            matches.value_source("alias"),
            Some(ValueSource::EnvVariable)
        );
        assert_eq!(
            matches.get_one::<String>("alias"),
            Some(&"env_alias".to_string())
        );

        // Test value from command line (overrides env var)
        let matches = get_parser().get_matches_from(vec!["--alias", "new_alias"]);
        assert_eq!(
            matches.value_source("alias"),
            Some(ValueSource::CommandLine)
        );
        assert_eq!(
            matches.get_one::<String>("alias"),
            Some(&"new_alias".to_string())
        );

        // Cleanup
        env::remove_var(ENV_VAR_NAME_ALIAS);
    }

    // This test is now independent and doesn't interfere.
    #[test]
    fn test_parser_other_arguments() {
        env::remove_var(ENV_VAR_NAME_SHELL);
        env::remove_var(ENV_VAR_NAME_HISTORY);

        // Test default shell
        assert_eq!(
            get_parser()
                .get_matches_from(Vec::<String>::new())
                .get_one::<String>("shell"),
            Some(&"bash".to_string())
        );

        // Test shell from command line
        assert_eq!(
            get_parser()
                .get_matches_from(vec!["-s", "zsh"])
                .get_one::<String>("shell"),
            Some(&"zsh".to_string())
        );

        // Test shell from environment variable
        env::set_var(ENV_VAR_NAME_SHELL, "pws");
        assert_eq!(
            get_parser()
                .get_matches_from(Vec::<String>::new())
                .get_one::<String>("shell"),
            Some(&"pws".to_string())
        );

        // Test debug flag
        assert!(get_parser()
            .get_matches_from(vec!["-d", "--", "anything"])
            .get_flag("debug"));

        // Test command from command line
        assert_eq!(
            get_parser()
                .get_matches_from(vec!["--", "ls", "-a"])
                .get_many::<String>("command")
                .unwrap()
                .collect::<Vec<_>>(),
            ["ls", "-a"]
        );

        // Test command from environment variable
        env::set_var(ENV_VAR_NAME_HISTORY, "ls -a\nls -lah");
        assert_eq!(
            get_parser()
                .get_matches_from(Vec::<String>::new())
                .get_many::<String>("command")
                .unwrap()
                .collect::<Vec<_>>(),
            ["ls -a\nls -lah"]
        );

        // Cleanup
        env::remove_var(ENV_VAR_NAME_SHELL);
        env::remove_var(ENV_VAR_NAME_HISTORY);
    }

    #[test]
    fn test_prepare_arguments() {
        for (input, exp_output) in [
            (
                vec![
                    "arg1".to_owned(),
                    "arg2".to_owned(),
                    ARGUMENT_PLACEHOLDER.to_owned(),
                    "arg3".to_owned(),
                ],
                vec!["arg3", "--", "arg1", "arg2"],
            ),
            (
                vec!["arg1".to_owned(), "arg2".to_owned(), "arg3".to_owned()],
                vec!["--", "arg1", "arg2", "arg3"],
            ),
            (
                vec!["-param".to_owned(), "arg2".to_owned(), "arg3".to_owned()],
                vec!["-param", "arg2", "arg3"],
            ),
        ] {
            assert_eq!(prepare_arguments(input), exp_output);
        }
    }

    /// Tests the argument processing logic.
    ///
    /// This test checks if the argument processing functions work as expected. It prepares some
    /// arguments, processes them, and verifies that the resulting command and shell type are as
    /// expected.
    ///
    /// The arguments used in this test are:
    /// - "arg1"
    /// - "arg2"
    /// - ARGUMENT_PLACEHOLDER
    /// - "--shell"
    /// - "custom_bash"
    ///
    /// The expected behavior is:
    /// - The resulting command should be ["arg1", "arg2"].
    /// - The shell type should be "custom_bash".
    #[test]
    fn test_process_arguments() {
        let prepared_args = prepare_arguments(vec![
            "arg1".to_owned(),
            "arg2".to_owned(),
            ARGUMENT_PLACEHOLDER.to_owned(),
            "--shell".to_owned(),
            "custom_bash".to_owned(),
        ]);
        let mut vec_matches = get_parser().get_matches_from(prepared_args);
        let command = vec_matches
            .remove_many::<String>("command")
            .expect("Command not found")
            .collect::<Vec<_>>();
        let shell_type = vec_matches.remove_one::<String>("shell");
        assert_eq!(command, ["arg1", "arg2"]);
        assert_eq!(shell_type, Some("custom_bash".to_owned()));
    }
}

// FILE: ./src/cli/mod.rs
pub mod command;
pub mod parser;

// FILE: ./src/cli/command.rs
use shlex::{split, Shlex};
use std::process::{Command, Stdio};
use std::{fmt, str};

use crate::shell::Shell;

#[derive(Debug)]
pub struct CorrectedCommand {
    pub script: String,
    pub side_effect: Option<fn(CrabCommand, Option<&str>)>,
    pub priority: u16,
}

impl CorrectedCommand {
    pub fn new(
        script: String,
        side_effect: Option<fn(CrabCommand, Option<&str>)>,
        priority: u16,
    ) -> Self {
        Self {
            script,
            side_effect,
            priority,
        }
    }
    pub fn get_script(&self) -> &String {
        &self.script
    }
    pub fn run(&self, old_command: CrabCommand) {
        if let Some(side_effect) = self.side_effect {
            (side_effect)(old_command, Some(&self.script));
        }
        println!("{}", self.get_script());
    }
}

#[derive(Debug)]
pub struct CrabCommand {
    pub script: String,
    pub output: Option<String>,
    pub script_parts: Vec<String>,
}

impl fmt::Display for CrabCommand {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "script: {}, output: {}",
            self.script,
            self.output.as_ref().unwrap_or(&"".to_owned()),
        )
    }
}

fn concat_stdout_stderr(stdout: Option<String>, stderr: Option<String>) -> Option<String> {
    match (stdout, stderr) {
        (Some(stdout), Some(stderr)) => Some({
            if !stderr.is_empty() && !stdout.is_empty() {
                format!("{}\n{}", stdout, &stderr)
            } else if !stderr.is_empty() {
                stderr
            } else {
                stdout
            }
        }),
        (Some(stdout), None) => Some(stdout),
        (None, Some(stderr)) => Some(stderr),
        (None, None) => None,
    }
}

impl CrabCommand {
    pub fn new(script: String, stdout: Option<String>, stderr: Option<String>) -> Self {
        let split_parts = CrabCommand::split_command(&script);
        let output = concat_stdout_stderr(stdout, stderr);

        CrabCommand {
            script,
            output,
            script_parts: split_parts,
        }
    }

    pub fn update(
        &self,
        script: Option<String>,
        stdout: Option<String>,
        stderr: Option<String>,
    ) -> CrabCommand {
        let output = concat_stdout_stderr(stdout, stderr);

        CrabCommand::new(
            script.unwrap_or(self.script.to_owned()),
            output.map_or(self.output.to_owned(), Some),
            None,
        )
    }

    fn split_command(command: &str) -> Vec<String> {
        // Split the command using shell-like syntax.
        shlex_split(command)
    }
}

/// Differently from shlex original split function, this function always returns the
/// resulting vector, even if there's an error.
pub fn shlex_split(in_str: &str) -> Vec<String> {
    let mut shl = Shlex::new(in_str);
    shl.by_ref().collect()
}

pub fn run_command(raw_command: Vec<String>, system_shell: &dyn Shell) -> CrabCommand {
    let command = prepare_command(raw_command);
    let mut output = shell_command(&system_shell.get_shell())
        .arg(&command)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .expect("Command failed to start")
        .wait_with_output()
        .expect("failed to wait on child");

    let exit_status = output.status;
    // output.status.success();
    let stdout = str::from_utf8(&output.stdout).map(|s| s.to_owned()).ok();
    let stderr = str::from_utf8(&output.stderr).map(|s| s.to_owned()).ok();
    CrabCommand::new(command, stdout, stderr)
}

fn prepare_command(raw_command: Vec<String>) -> String {
    // TODO: Expand aliases (`shell.from_shell()`)
    raw_command.join(" ").trim().to_owned()
}

pub fn shell_command(words_str: &str) -> Command {
    let mut words_vec = split(words_str).expect("empty shell command");
    let mut words = words_vec.iter_mut();
    let first_cmd = words.next().expect("absent shell binary");
    let dash_c = if words_str.contains("cmd.exe") {
        "/c"
    } else {
        "-c"
    };
    let mut cmd = Command::new(first_cmd);
    cmd.args(words);
    cmd.arg(dash_c);
    cmd
}

#[cfg(test)]
mod tests {
    use crate::{
        cli::command::shell_command,
        shell::{Bash, Shell},
    };

    use super::run_command;

    #[test]
    fn test_shell_command() {
        let shell_name = "bash".to_owned();
        let cmd = shell_command(&shell_name);
        assert_eq!(cmd.get_args().len(), 1);
        assert_eq!(cmd.get_program().to_str().unwrap(), shell_name);
    }

    #[cfg(target_family = "unix")]
    #[test]
    fn test_run_command() {
        let terminal_command = {
            if cfg!(target_family = "unix") {
                "echo"
            } else {
                "Write-Output"
            }
        };
        let command_vec = vec![terminal_command.to_owned(), "Hello!".to_owned()];
        let command = command_vec.join(" ").trim().to_owned();
        let system_shell: Box<dyn Shell> = Box::new(Bash {});
        let crab_command = run_command(command_vec, &*system_shell);
        assert_eq!(crab_command.script, command);
        assert_eq!(crab_command.output.unwrap(), "Hello!\n");
    }

    #[cfg(target_family = "unix")]
    #[test]
    fn test_run_command_with_error() {
        let command_vec = vec!["ls".to_owned(), "non_existent_directory".to_owned()];
        let command = command_vec.join(" ").trim().to_owned();
        let system_shell: Box<dyn Shell> = Box::new(Bash {});
        let crab_command = run_command(command_vec, &*system_shell);
        assert_eq!(crab_command.script, command);
        assert!(crab_command
            .output
            .unwrap()
            .contains("No such file or directory"));
    }
}

// FILE: ./tests/main_integration_tests.rs
use assert_cmd::Command;
use predicates::prelude::*;

#[test]
fn test_alias_generation() {
    let mut cmd = Command::cargo_bin("ohcrab").unwrap();
    cmd.arg("--alias=crabalias")
        .assert()
        .success()
        .stdout(predicate::str::contains("crabalias"));
}

#[test]
fn test_command_correction_suggestion() {
    let mut cmd = Command::cargo_bin("ohcrab").unwrap();
    cmd.arg("--select-first")
        .arg("--")
        // Use a command with a single, correctable error
        .arg("git")
        .arg("brnch")
        .assert()
        .success()
        // Assert the correct, single-step suggestion
        .stdout(predicate::str::contains("git branch"));
}

#[test]
fn test_debug_output() {
    let mut cmd = Command::cargo_bin("ohcrab").unwrap();
    cmd.arg("--select-first")
        .arg("--debug")
        .arg("--")
        // Use the same robust command here
        .arg("git")
        .arg("brnch")
        .assert()
        .success()
        .stdout(
            predicate::str::contains("Retrieved command(s):")
                .and(predicate::str::contains("git branch")),
        );
}

// Command with Quoted Arguments
/// Tests if a command with quoted arguments is corrected properly.
/// This ensures that the argument parsing logic (shlex) correctly handles quotes and spaces.
#[test]
fn test_command_with_quotes() {
    let mut cmd = Command::cargo_bin("ohcrab").unwrap();
    cmd.arg("--select-first")
        .arg("--")
        // Pass the entire command as a single argument to simulate shell behavior
        .arg("git comit -m \"a message with spaces\"")
        .assert()
        .success()
        .stdout(predicate::str::contains(
            "git commit -m \"a message with spaces\"",
        ));
}

// Command Corrected by `no_command` Rule
/// Tests a command with a typo in the executable name itself.
/// This relies on the `no_command` rule, which has a higher priority, to suggest a correction
/// from the list of available system executables.
#[test]
fn test_executable_typo_correction() {
    let mut cmd = Command::cargo_bin("ohcrab").unwrap();
    cmd.arg("--select-first")
        .arg("--")
        .arg("gti") // Typo for "git"
        .arg("status")
        .assert()
        .success()
        .stdout(predicate::str::contains("git status"));
}

// Rule that Creates a Directory (`no_such_file`)
/// Tests the `no_such_file` rule for `cp`, which fails when the destination directory doesn't exist.
/// The corrected command should first create the directory and then execute the original command.
#[test]
fn test_command_creating_directory() {
    // Setup a temporary directory for the test
    let temp_dir = tempfile::tempdir().unwrap();
    let file_path = temp_dir.path().join("file.txt");
    std::fs::write(&file_path, "content").unwrap();

    let mut cmd = Command::cargo_bin("ohcrab").unwrap();
    cmd.current_dir(temp_dir.path())
        .arg("--select-first")
        .arg("--debug") // Keep debug for useful output if it fails
        .arg("--")
        .arg("cp")
        .arg("file.txt")
        .arg("non_existent_dir/file.txt")
        .assert()
        .success()
        // This is the corrected assertion:
        .stdout(predicate::str::contains(
            "mkdir -p non_existent_dir && cp file.txt non_existent_dir/file.txt",
        ));
}

// Piped Command Correction
/// Tests if `ohcrab` can correct the failing part of a piped command.
/// The `no_command` rule should correct `lss` to `ls`.
#[test]
fn test_piped_command() {
    let mut cmd = Command::cargo_bin("ohcrab").unwrap();
    cmd.arg("--select-first")
        .arg("--")
        .arg("gitt status | grep foo") // `gitt` is a less ambiguous typo for `git`
        .assert()
        .success()
        .stdout(predicate::str::contains("git status | grep foo"));
}

// FILE: ./src/shell/mod.rs
use std::env;
use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

use crate::{ARGUMENT_PLACEHOLDER, ENV_VAR_NAME_ALIAS, ENV_VAR_NAME_HISTORY, ENV_VAR_NAME_SHELL};

pub trait Shell {
    fn app_alias(&self, alias_name: &str) -> String;
    fn get_shell(&self) -> String;
    fn get_history_file_name(&self) -> String;
    fn script_from_history(&self, command_script: &str) -> String {
        command_script.to_owned()
    }

    fn get_history(&self, file_path: Option<&str>) -> Vec<String> {
        let history_file_name = {
            if let Some(path) = file_path {
                path.to_owned()
            } else {
                self.get_history_file_name()
            }
        };
        let mut history: Vec<String> = Vec::new();
        if Path::new(&history_file_name).exists() {
            if let Ok(file) = File::open(&history_file_name) {
                let reader = io::BufReader::new(file);

                // TODO: Limit history length based on settings
                for line in reader.lines() {
                    let prepared = self.script_from_history(&line.unwrap_or("".to_owned()));
                    let prepared = prepared.trim();
                    if !prepared.is_empty() {
                        history.push(prepared.to_owned());
                    }
                }
            }
        }
        history
    }
    fn and(&self, commands: Vec<&str>) -> String {
        commands.join(" && ")
    }

    fn get_builtin_commands(&self) -> Vec<String> {
        vec![
            "alias".to_owned(),
            "bg".to_owned(),
            "bind".to_owned(),
            "break".to_owned(),
            "builtin".to_owned(),
            "case".to_owned(),
            "cd".to_owned(),
            "command".to_owned(),
            "compgen".to_owned(),
            "complete".to_owned(),
            "continue".to_owned(),
            "declare".to_owned(),
            "dirs".to_owned(),
            "disown".to_owned(),
            "echo".to_owned(),
            "enable".to_owned(),
            "eval".to_owned(),
            "exec".to_owned(),
            "exit".to_owned(),
            "export".to_owned(),
            "fc".to_owned(),
            "fg".to_owned(),
            "getopts".to_owned(),
            "hash".to_owned(),
            "help".to_owned(),
            "history".to_owned(),
            "if".to_owned(),
            "jobs".to_owned(),
            "kill".to_owned(),
            "let".to_owned(),
            "local".to_owned(),
            "logout".to_owned(),
            "popd".to_owned(),
            "printf".to_owned(),
            "pushd".to_owned(),
            "pwd".to_owned(),
            "read".to_owned(),
            "readonly".to_owned(),
            "return".to_owned(),
            "set".to_owned(),
            "shift".to_owned(),
            "shopt".to_owned(),
            "source".to_owned(),
            "suspend".to_owned(),
            "test".to_owned(),
            "times".to_owned(),
            "trap".to_owned(),
            "type".to_owned(),
            "typeset".to_owned(),
            "ulimit".to_owned(),
            "umask".to_owned(),
            "unalias".to_owned(),
            "unset".to_owned(),
            "until".to_owned(),
            "wait".to_owned(),
            "while".to_owned(),
        ]
    }
}

pub fn get_bash_type(shell_type: &str) -> Box<dyn Shell> {
    let shell_candidate = shell_type.to_lowercase();
    match shell_candidate.as_str() {
        "zsh" => Box::new(Zsh),
        "bash" => Box::new(Bash),
        _ => panic!("The shell '{shell_type}' is not supported yet"),
    }
}

pub struct Zsh;
pub struct Bash;

impl Shell for Zsh {
    fn get_shell(&self) -> String {
        "zsh".to_owned()
    }

    fn app_alias(&self, alias_name: &str) -> String {
        format!(
            r#"
            {alias_name} () {{
                export {ENV_VAR_NAME_SHELL}="zsh";
                export {ENV_VAR_NAME_ALIAS}="{alias_name}";
                export {ENV_VAR_NAME_HISTORY}="$(fc -ln -1)";
                OC_CMD=$(
                    ohcrab {ARGUMENT_PLACEHOLDER} $@
                ) && eval $OC_CMD;
                unset {ENV_VAR_NAME_HISTORY};
            }}
            "#,
        )
    }

    fn script_from_history(&self, command_script: &str) -> String {
        if command_script.contains(';') {
            command_script.split_once(';').unwrap().1.to_owned()
        } else {
            "".to_owned()
        }
    }

    fn get_history_file_name(&self) -> String {
        match env::var("HISTFILE") {
            Ok(val) => val,
            Err(_) => dirs::home_dir()
                .unwrap()
                .join(".zsh_history")
                .to_str()
                .unwrap()
                .to_string(),
        }
    }
}

impl Shell for Bash {
    fn get_shell(&self) -> String {
        "bash".to_owned()
    }

    fn app_alias(&self, alias_name: &str) -> String {
        format!(
            r#"
            function {alias_name} () {{
                export {ENV_VAR_NAME_SHELL}="bash";
                export {ENV_VAR_NAME_ALIAS}="{alias_name}";
                export {ENV_VAR_NAME_HISTORY}="$(fc -ln -1)";
                OC_CMD=$(
                    ohcrab {ARGUMENT_PLACEHOLDER} "$@"
                ) && eval "$OC_CMD";
                unset {ENV_VAR_NAME_HISTORY};
            }}
            "#,
        )
    }

    fn get_history_file_name(&self) -> String {
        match env::var("HISTFILE") {
            Ok(val) => val,
            Err(_) => dirs::home_dir()
                .unwrap()
                .join(".bash_history")
                .to_str()
                .unwrap()
                .to_string(),
        }
    }
}

#[cfg(test)]
mod test_zsh {
    use crate::shell::Shell;
    use std::io::Write;
    use tempfile::NamedTempFile;

    use super::Zsh;

    #[test]
    fn test_get_history() {
        // Create a file inside of `std::env::temp_dir()`.
        let mut file = NamedTempFile::new().unwrap();

        writeln!(
            file,
            ": 1702325001:0;ls -lah\n: 1702325001:0;cd /tmp\n: 1702325001:0;nvim"
        )
        .unwrap();
        let path = file.path().to_str().unwrap();

        let system_shell = Zsh {};
        assert_eq!(
            system_shell.get_history(Some(path)),
            vec!["ls -lah", "cd /tmp", "nvim"]
        );
    }
}

// FILE: ./src/ui.rs
use crate::cli::command::CorrectedCommand;
use console::{style, Key, Term};
use std::io::{self, Write};

/// Displays the confirmation text for a given corrected command.
///
/// # Arguments
///
/// * `command` - A reference to a `CorrectedCommand`.
pub fn confirm_text(command: &CorrectedCommand) {
    let prefix = "\r\x1B[K";
    eprint!(
        "\r{}{}{} [{}|{}|{}|{}]",
        prefix,
        style(command.script.to_owned()).for_stderr().bold(),
        if command.side_effect.is_some() {
            " (+side_effect)"
        } else {
            ""
        },
        style("enter").for_stderr().green(),
        style("↑/k").for_stderr().blue(),
        style("↓/j").for_stderr().blue(),
        style("CTRL+c").for_stderr().red()
    );
}

/// Implements an interactive menu for selecting from a list of corrected commands.
///
/// # Arguments
///
/// * `corrected_commands` - A reference to a vector of `CorrectedCommand`.
///
/// # Returns
///
/// An optional reference to the selected `CorrectedCommand`.
pub fn interactive_menu(corrected_commands: &[CorrectedCommand]) -> Option<&CorrectedCommand> {
    if corrected_commands.is_empty() {
        return None;
    }

    let mut index = 0;
    let term = Term::stderr();
    let num_items = corrected_commands.len();

    let draw_menu = |index: usize| {
        if let Some(command) = corrected_commands.get(index) {
            confirm_text(command);
            io::stderr().flush().unwrap();
        }
    };

    draw_menu(index);

    loop {
        if let Ok(key) = term.read_key() {
            match key {
                Key::ArrowUp | Key::Char('k') => {
                    index = (index + num_items - 1) % num_items;
                }
                Key::ArrowDown | Key::Char('j') => {
                    index = (index + 1) % num_items;
                }
                Key::Enter => {
                    return corrected_commands.get(index);
                }
                Key::Char(c) => {
                    // Clear the line before exiting
                    let prefix = "\r\x1B[K";
                    eprint!("{}", prefix);
                    return None;
                }
                _ => {}
            }
            draw_menu(index);
        }
    }
}

// FILE: ./build.rs
use std::env;
use std::fs;
use std::path::Path;
use walkdir::WalkDir;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let destination = Path::new(&out_dir).join("rules.rs");

    let mut rule_mods = Vec::new();
    let mut rule_registrations = Vec::new();

    println!("cargo:rerun-if-changed=src/rules");

    for entry in WalkDir::new("src/rules").into_iter().filter_map(|e| e.ok()) {
        let path = entry.path();
        if path.is_file() {
            if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                // Adjust this list to ignore any non-rule files in the directory
                if file_stem != "mod" && file_stem != "utils" && file_stem != "parameterized_tests"
                {
                    println!("cargo:rerun-if-changed={}", path.display());

                    // Generate: mod my_rule;
                    rule_mods.push(format!("mod {};", file_stem));

                    // Generate: my_rule::get_rule(),
                    rule_registrations.push(format!("{}::get_rule(),", file_stem));
                }
            }
        }
    }

    let generated_code = format!(
        "// This file is automatically generated by build.rs\n\
         // Do not edit manually.\n\
         \n\
         {}\n\
         \n\
         pub fn get_rules() -> Vec<Rule> {{\n\
             vec![\n\
                 {}\n\
             ]\n\
         }}",
        rule_mods.join("\n"),
        rule_registrations.join("\n                 ")
    );

    fs::write(&destination, generated_code).unwrap();
}

// FILE: ./Cargo.toml
[package]
name = "ohcrab"
version = "0.7.5"
edition = "2021"
description = "Fix your command line magically"
authors = ["Luiz Otavio Vilas Boas Oliveira <luiz.vbo@gmail.com>"]
license = "MIT"
repository = "https://github.com/luizvbo/oh-crab"
readme = "README.md"
keywords = ["fix", "command", "terminal"]
categories = ["command-line-utilities"]
rust-version = "1.70.0"

[dependencies]
clap = { version = "4.4.7", features = ["cargo", "env"] }
shlex = "1.3.0"
which = "4.4.0"
fuzzt = { version = "0.3.1", default-features = false }
console = "0.15.7"
dirs = "5.0.1"
regex = "1.10.2"
is_executable = "1.0.1"
tar = { version = "0.4.40", optional = true }

[features]
tar = ["dep:tar"]

[profile.release]
lto = true        # Enable link-time optimization
strip = true      # Strip symbols from binary*
codegen-units = 1 # Reduce number of codegen units to increase optimizations

[dev-dependencies]
mockall = "0.12.0"
tempfile = "3.10.1"
rstest = "0.18.2"
assert_cmd = "2.0.13"
predicates = "3.1.0"

[target.aarch64-apple-darwin]
linker = "/usr/local/bin/aarch64-linux-musl-gcc"

[build-dependencies]
walkdir = "2"

// FILE: ./typos.toml
[default.extend-words]
Sie = "Sie"
buid = "buid"
buils = "buils"
buld = "buld"
comit = 'comit'
evn = "evn"
fo = "fo"
goood = "goood"
gti = 'gti'
sie = "sie"
udpate = "udpate"

