use std::env;
use std::fs;
use std::path::Path;
use walkdir::WalkDir;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let destination = Path::new(&out_dir).join("rules.rs");
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    let mut rule_mods = Vec::new();
    let mut rule_registrations = Vec::new();

    println!("cargo:rerun-if-changed=src/rules");

    // This loop now only looks at files directly inside `src/rules`
    for entry in WalkDir::new("src/rules")
        .min_depth(1) // Skip the `src/rules` directory itself
        .max_depth(1) // Do not go into subdirectories
        .into_iter()
        .filter_map(|e| e.ok())
    {
        let path = entry.path();
        if path.is_file() {
            if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                if file_stem != "mod" {
                    let absolute_path = Path::new(&manifest_dir).join(path);
                    let path_str = absolute_path.to_str().unwrap().replace('\\', "/");

                    rule_mods.push(format!("#[path = \"{path_str}\"]\nmod {file_stem};"));
                    rule_registrations.push(format!("{file_stem}::get_rule(),"));
                }
            }
        }
    }

    let generated_code = format!(
        "// This file is automatically generated by build.rs\n\
         // Do not edit manually.\n\
         \n\
         {}\n\
         \n\
         pub fn get_rules() -> Vec<Rule> {{\n\
             vec![\n\
                 {}\n\
             ]\n\
         }}",
        rule_mods.join("\n"),
        rule_registrations.join("\n                 ")
    );

    fs::write(&destination, generated_code).unwrap();
}
